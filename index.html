<!DOCTYPE html>
<html lang="ja" class="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="referrer" content="strict-origin-when-cross-origin">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="BookLog">
    <meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#000000" media="(prefers-color-scheme: dark)">

    <title>BookLog</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['"Meiryo UI"', '"Microsoft JhengHei UI"', '"Hiragino Kaku Gothic ProN"', '-apple-system', 'sans-serif'],
                        mono: ['"Consolas"', '"Monaco"', 'monospace'],
                        zen: ['"Yu Mincho"', '"Hiragino Mincho ProN"', 'serif'],
                    },
                    colors: {
                        darkBg: "#000000",
                        darkCard: "#1c1c1e",
                        darkBorder: "#2c2c2e",
                        accent: "#007AFF",
                    },
                    boxShadow: {
                        'glass': '0 4px 30px rgba(0, 0, 0, 0.1)',
                        'apple-card': '0 8px 24px rgba(0, 0, 0, 0.04)',
                        'apple-float': '0 20px 40px rgba(0, 0, 0, 0.12)',
                        'glow': '0 0 20px rgba(var(--accent-rgb), 0.4)',
                    },
                    animation: {
                        'fade-in': 'fadeIn 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
                        'zoom-in': 'zoomIn 0.25s cubic-bezier(0.2, 0.8, 0.2, 1) forwards',
                        'shimmer': 'shimmer 1.5s infinite linear',
                        'pop-in': 'popIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards',
                    },
                    keyframes: {
                        fadeIn: { '0%': { opacity: '0' }, '100%': { opacity: '1' } },
                        zoomIn: { '0%': { opacity: '0', transform: 'scale(0.92)' }, '100%': { opacity: '1', transform: 'scale(1)' } },
                        shimmer: { '0%': { transform: 'translateX(-100%)' }, '100%': { transform: 'translateX(100%)' } },
                        popIn: { '0%': { opacity: '0', transform: 'translateY(-10px) scale(0.9)' }, '100%': { opacity: '1', transform: 'translateY(0) scale(1)' } }
                    }
                }
            }
        }
    </script>
    <style>
        /* === View Transitions API === */
        ::view-transition-group(root) { animation-duration: 0.4s; animation-timing-function: cubic-bezier(0.16, 1, 0.3, 1); }
        ::view-transition-old(root) { animation: 90ms cubic-bezier(0.4, 0, 1, 1) both fade-out; }
        ::view-transition-new(root) { animation: 210ms cubic-bezier(0, 0, 0.2, 1) 90ms both fade-in; }

        /* Morphing Transitions for Modal */
        ::view-transition-group(morph-modal-card),
        ::view-transition-group(morph-modal-cover) {
            animation-duration: 0.45s;
            animation-timing-function: cubic-bezier(0.25, 1, 0.5, 1);
        }
        ::view-transition-old(morph-modal-card),
        ::view-transition-new(morph-modal-card),
        ::view-transition-old(morph-modal-cover),
        ::view-transition-new(morph-modal-cover) {
            mix-blend-mode: normal;
        }

        /* === ADAPTIVE COLOR SYSTEM === */
        :root {
            --accent-color: #007AFF; --accent-rgb: 0, 122, 255;
            --text-main: #1d1d1f; 
            --bg-modal-input: #f2f2f7;
            --highlight-bg: #fffba0; --highlight-text: #000;
        }
        .dark {
            --accent-color: #0A84FF; --accent-rgb: 10, 132, 255;
            --text-main: #f5f5f7; 
            --bg-modal-input: #2c2c2e;
            --highlight-bg: #ffd60a; --highlight-text: #000;
        }

        * { -webkit-tap-highlight-color: transparent; outline: none; }
        body { overscroll-behavior-y: none; }
        *:not(.rounded-smooth) { border-radius: 0; }
        .rounded-smooth { border-radius: 12px !important; }
        ::-webkit-scrollbar { width: 0px; height: 0px; background: transparent; }

        .search-highlight { background-color: var(--highlight-bg); color: var(--highlight-text); padding: 0 2px; border-radius: 3px; font-weight: 600; }
        .view-content { animation: fadeIn 0.4s ease-out; }
        #modalCard { transform-origin: center center; }
        /* モーフィング中はデフォルトのzoomInを無効化 */
        #modal.open:not(.morphing) #modalCard { animation: zoomIn 0.25s cubic-bezier(0.2, 0.8, 0.2, 1) forwards; }

        /* === GRID SYSTEM === */
        .book-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 1.5rem 1rem; width: 100%; padding-bottom: 4rem; }
        @media (min-width: 640px) { .book-grid { grid-template-columns: repeat(4, 1fr); gap: 2rem 1.5rem; } }
        @media (min-width: 1024px) { .book-grid { grid-template-columns: repeat(6, 1fr); gap: 3rem 2rem; } }
        @media (min-width: 1280px) { .book-grid { grid-template-columns: repeat(8, 1fr); } }

        .book-card-container { position: relative; width: 100%; aspect-ratio: 2 / 3.2; z-index: 1; transition: z-index 0s 0.3s; }
        .book-card-container:hover { z-index: 50; transition: z-index 0s; }
        .haptic-tap:active, .book-card-container:active .book-card { transform: scale(0.96); transition: transform 0.1s cubic-bezier(0.2, 0, 0, 1); }
        .book-card { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1), box-shadow 0.3s ease; border-radius: 12px; background: transparent; transform-origin: center center; }
        .book-card-container:hover .book-card { height: auto; min-height: 100%; transform: scale(1.03) translateY(-6px); background: #fff; box-shadow: var(--apple-float); padding-bottom: 12px; z-index: 20; }
        .dark .book-card-container:hover .book-card { background: #1c1c1e; border: 1px solid rgba(255,255,255,0.1); }
        .book-img-wrapper { position: relative; width: 100%; padding-bottom: 150%; background-color: #f2f2f7; border-radius: 10px; overflow: hidden; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08); margin-bottom: 10px; border: 1px solid rgba(0,0,0,0.02); }
        .dark .book-img-wrapper { background-color: #2c2c2e; border: 1px solid rgba(255,255,255,0.05); }
        .shimmer-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent); transform: skewX(-20deg); pointer-events: none; }
        .dark .shimmer-overlay { background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent); }
        .loading .shimmer-overlay { animation: shimmer 1.5s infinite; }
        .book-cover-image { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 10; transition: transform 0.4s ease; }
        .book-card-container:hover .book-cover-image { transform: scale(1.02); }
        .rank-jewel { position: absolute; top: 6px; right: 6px; padding: 2px 8px; border-radius: 6px; font-size: 0.65rem; font-weight: 800; backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); z-index: 20; box-shadow: 0 2px 10px rgba(0,0,0,0.1); border: 1px solid rgba(255,255,255,0.3); color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.2); }
        .rank-S { background: rgba(255, 179, 64, 0.85); box-shadow: 0 0 15px rgba(255, 179, 64, 0.5); } .rank-A { background: rgba(142, 142, 147, 0.85); } .rank-B { background: rgba(174, 86, 34, 0.85); } .rank-C { background: rgba(99, 99, 102, 0.85); }
        
        .book-title { font-size: 0.75rem; font-weight: 600; line-height: 1.35; color: var(--text-main); letter-spacing: -0.01em; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
        .book-card-container:hover .book-title { -webkit-line-clamp: unset; } 
        .book-author { font-size: 0.65rem; color: #8e8e93; margin-top: 3px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .book-card-container:hover .book-author { white-space: normal; }

        /* UI Components */
        .liquid-glass { background: rgba(255, 255, 255, 0.65); backdrop-filter: blur(20px) saturate(180%); -webkit-backdrop-filter: blur(20px) saturate(180%); border: 1px solid rgba(255, 255, 255, 0.3); box-shadow: 0 4px 10px rgba(0,0,0,0.03); }
        .dark .liquid-glass { background: rgba(28, 28, 30, 0.65); border-color: rgba(255, 255, 255, 0.1); }
        .liquid-nav-container { position: relative; display: flex; background: rgba(118, 118, 128, 0.12); padding: 2px; border-radius: 10px !important; height: 32px; }
        .dark .liquid-nav-container { background: rgba(118, 118, 128, 0.24); }
        .liquid-highlighter { position: absolute; top: 2px; bottom: 2px; left: 0; background: #fff; border-radius: 8px !important; transition: all 0.25s cubic-bezier(0.2, 0.8, 0.2, 1); box-shadow: 0 2px 6px rgba(0,0,0,0.1); }
        .dark .liquid-highlighter { background: #636366; }
        .liquid-tab { position: relative; z-index: 1; flex: 1; display: flex; align-items: center; justify-content: center; font-size: 0.65rem; font-weight: 600; color: #636366; cursor: pointer; padding: 0; text-align: center; transition: color 0.2s; }
        .liquid-tab.active { color: #000; }
        .dark .liquid-tab.active { color: #fff; }
        .dark .liquid-tab { color: #aeaeb2; }

        /* === TAG System UI === */
        .tag-input-container { display: flex; flex-wrap: wrap; gap: 6px; padding: 10px; background: var(--bg-modal-input); border-radius: 10px; min-height: 44px; cursor: text; border: 1px solid transparent; transition: border-color 0.2s; }
        .tag-input-container:focus-within { border-color: var(--accent-color); }
        .tag-chip { display: inline-flex; align-items: center; padding: 4px 10px; border-radius: 20px; font-size: 0.7rem; font-weight: 600; background: rgba(var(--accent-rgb), 0.1); color: var(--accent-color); cursor: default; transition: all 0.2s; }
        .tag-chip:hover { background: rgba(var(--accent-rgb), 0.2); }
        .tag-remove { margin-left: 6px; cursor: pointer; opacity: 0.5; font-size: 0.9rem; line-height: 0.8; } .tag-remove:hover { opacity: 1; }
        .tag-input { flex: 1; min-width: 60px; background: transparent; border: none; font-size: 0.75rem; outline: none; color: var(--text-main); }
        .tag-header { display: flex; align-items: center; padding: 16px 0; margin-bottom: 12px; border-bottom: 1px solid rgba(0,0,0,0.05); }
        .dark .tag-header { border-bottom-color: rgba(255,255,255,0.1); }
        .tag-title { font-size: 1rem; font-weight: 700; margin-right: 10px; color: var(--text-main); letter-spacing: -0.02em; }
        .tag-count { background: var(--bg-modal-input); padding: 2px 10px; border-radius: 12px; font-size: 0.7rem; font-weight: 600; color: #8e8e93; }

        /* Rich Editor */
        .rich-editor-wrapper { position: relative; background: var(--bg-modal-input); border-radius: 14px; transition: all 0.3s ease; border: 1px solid transparent; overflow: visible; }
        .rich-editor-wrapper:focus-within { background: #fff; box-shadow: 0 4px 20px rgba(0,0,0,0.05); border-color: var(--accent-color); }
        .dark .rich-editor-wrapper:focus-within { background: #1c1c1e; box-shadow: 0 4px 20px rgba(0,0,0,0.3); }
        .rich-toolbar { position: absolute; bottom: 100%; right: 0; margin-bottom: 8px; display: flex; align-items: center; justify-content: flex-end; gap: 6px; padding: 6px; background: rgba(255, 255, 255, 0.85); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-radius: 40px; box-shadow: 0 10px 30px rgba(0,0,0,0.15), 0 0 0 1px rgba(0,0,0,0.05); z-index: 100; opacity: 0; transform: translateY(10px) scale(0.95); pointer-events: none; width: auto; max-width: 140px; transition: opacity 0.2s ease, transform 0.4s cubic-bezier(0.25, 1, 0.5, 1), max-width 0.4s cubic-bezier(0.25, 1, 0.5, 1), margin 0.3s ease; }
        .dark .rich-toolbar { background: rgba(44, 44, 46, 0.85); box-shadow: 0 10px 30px rgba(0,0,0,0.5), 0 0 0 1px rgba(255,255,255,0.1); }
        .rich-editor-wrapper:hover .rich-toolbar, .rich-editor-wrapper:focus-within .rich-toolbar { opacity: 1; transform: translateY(0) scale(1); pointer-events: auto; }
        .rich-toolbar.expanded { max-width: 280px; padding-left: 12px; background: #fff; z-index: 9999; }
        .dark .rich-toolbar.expanded { background: #3a3a3c; }
        .rich-toolbar.pos-bottom { bottom: auto; top: 100%; margin-bottom: 0; margin-top: 8px; }
        @media (max-width: 480px) { .rich-toolbar.mobile-fixed { position: fixed !important; bottom: 30px !important; top: auto !important; left: 50% !important; right: auto !important; margin: 0 !important; transform: translateX(-50%) translateY(100%) !important; width: 90% !important; max-width: 360px !important; justify-content: space-between !important; padding: 12px 20px !important; box-shadow: 0 15px 50px rgba(0,0,0,0.3) !important; border: 1px solid rgba(255,255,255,0.1) !important; opacity: 0 !important; } .rich-toolbar.mobile-fixed.expanded { transform: translateX(-50%) translateY(0) !important; opacity: 1 !important; } }
        .toolbar-inner { display: flex; align-items: center; gap: 6px; width: 100%; justify-content: flex-end; }
        .integrated-palette { display: flex; align-items: center; gap: 6px; width: 0; opacity: 0; overflow: hidden; white-space: nowrap; transition: width 0.4s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.3s ease; }
        .rich-toolbar.expanded .integrated-palette { width: 130px; opacity: 1; padding-right: 8px; border-right: 1px solid rgba(0,0,0,0.1); margin-right: 8px; flex-shrink: 0; }
        .dark .rich-toolbar.expanded .integrated-palette { border-right-color: rgba(255,255,255,0.1); }
        .rich-btn { width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 8px; color: #666; cursor: pointer; transition: all 0.2s; font-family: serif; font-weight: 800; flex-shrink: 0; }
        .dark .rich-btn { color: #aeaeb2; }
        .rich-btn:hover { background: rgba(var(--accent-rgb), 0.1); color: var(--accent-color); }
        .rich-btn.active-tool { background: var(--accent-color); color: #fff; box-shadow: 0 2px 8px rgba(var(--accent-rgb), 0.3); }
        .toolbar-divider { width: 1px; height: 16px; background: rgba(0,0,0,0.1); margin: 0 2px; flex-shrink: 0; }
        .dark .toolbar-divider { background: rgba(255,255,255,0.15); }
        .marker-trigger-btn { transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1); }
        .rich-toolbar.expanded .marker-trigger-btn { transform: rotate(45deg); color: #ff3b30; }
        .color-gem { width: 22px; height: 22px; border-radius: 50%; cursor: pointer; border: 2px solid transparent; transition: transform 0.2s; flex-shrink: 0; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .color-gem:hover { transform: scale(1.2); }
        .gem-yellow { background: #ffd60a; } .gem-green { background: #32d74b; } .gem-pink { background: #ff375f; } .gem-blue { background: #0a84ff; } .gem-purple { background: #bf5af2; }
        [class^="marker-"] { background: linear-gradient(transparent 60%, var(--m-color) 60%); padding: 0 2px; border-radius: 2px; }
        .marker-yellow { --m-color: #fef08a; } .marker-green { --m-color: #bbf7d0; } .marker-pink { --m-color: #fbcfe8; } .marker-blue { --m-color: #bae6fd; } .marker-purple { --m-color: #e9d5ff; }
        .dark .marker-yellow { --m-color: rgba(255, 214, 10, 0.3); } .dark .marker-green { --m-color: rgba(50, 215, 75, 0.3); } .dark .marker-pink { --m-color: rgba(255, 55, 95, 0.3); } .dark .marker-blue { --m-color: rgba(10, 132, 255, 0.3); } .dark .marker-purple { --m-color: rgba(191, 90, 242, 0.3); }
        .rich-content { width: 100%; min-height: 140px; padding: 20px; font-size: 0.92rem; line-height: 1.8; color: var(--text-main); outline: none; white-space: pre-wrap; overflow-y: auto; font-family: "Hiragino Kaku Gothic ProN", sans-serif; }
        .rich-content u { text-decoration-thickness: 2px; text-decoration-color: rgba(var(--accent-rgb), 0.3); }
        .selection-guide { position: absolute; top: -40px; right: 0; background: #1c1c1e; color: #fff; padding: 6px 12px; border-radius: 8px; font-size: 0.75rem; font-weight: 600; pointer-events: none; opacity: 0; transform: translateY(5px); transition: 0.2s; white-space: nowrap; z-index: 200; box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
        .selection-guide.show { opacity: 1; transform: translateY(0); }

        /* Zen Mode */
        #zenOverlay { position: fixed; inset: 0; z-index: 999999; background-color: rgba(255,255,255,0.98); backdrop-filter: blur(10px); display: flex; flex-direction: column; align-items: center; opacity: 0; pointer-events: none; transition: opacity 0.5s ease-in-out; }
        .dark #zenOverlay { background-color: rgba(0,0,0,0.98); }
        #zenOverlay.active { opacity: 1; pointer-events: auto; }
        .zen-textarea { width: 100%; max-width: 800px; height: 100%; padding: 4rem 2rem; background: transparent; border: none; outline: none; resize: none; font-family: "Yu Mincho", "Hiragino Mincho ProN", serif; font-size: 1.25rem; line-height: 2.2; color: #1d1d1f; }
        .dark .zen-textarea { color: #f5f5f7; }
        .zen-close-btn { position: absolute; top: 2rem; right: 2rem; opacity: 0.5; cursor: pointer; color: var(--text-main); font-weight: 600; transition: opacity 0.2s; }
        .zen-close-btn:hover { opacity: 1; }
        .zen-trigger { position: absolute; bottom: 10px; right: 10px; opacity: 0; transition: opacity 0.2s; color: #8e8e93; cursor: pointer; z-index: 30; padding: 4px; }
        .rich-editor-wrapper:hover .zen-trigger { opacity: 1; }

        /* Popovers */
        .popover-container { position: relative; }
        .absolute-popover { position: absolute; top: 100%; right: 0; margin-top: 6px; width: 220px; background: rgba(255, 255, 255, 0.85); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-radius: 12px !important; box-shadow: 0 10px 40px rgba(0,0,0,0.15), 0 0 0 1px rgba(0,0,0,0.05); z-index: 50; display: none; }
        .dark .absolute-popover { background: rgba(44, 44, 46, 0.85); box-shadow: 0 10px 40px rgba(0,0,0,0.5), 0 0 0 1px rgba(255,255,255,0.1); }
        .absolute-popover.open { display: block; animation: popIn 0.2s cubic-bezier(0.2, 0.8, 0.2, 1) forwards; }
        .floating-popover { position: fixed; width: 180px; background: rgba(255, 255, 255, 0.9); backdrop-filter: blur(20px); border-radius: 12px !important; box-shadow: 0 20px 60px rgba(0,0,0,0.25); z-index: 100000; display: none; }
        .dark .floating-popover { background: rgba(44, 44, 46, 0.9); border: 1px solid rgba(255,255,255,0.1); }
        .floating-popover.open { display: block; }
        .popover-item { display: flex; justify-content: space-between; padding: 12px 16px; font-size: 0.75rem; font-weight: 600; color: var(--text-main); cursor: pointer; border-bottom: 1px solid rgba(0,0,0,0.05); transition: background 0.1s; }
        .dark .popover-item { border-color: rgba(255,255,255,0.05); }
        .popover-item:hover { background: rgba(var(--accent-rgb),0.1); color: var(--accent-color); }
        .popover-item.selected { color: var(--accent-color); background: transparent; }
        .popover-check { display: none; } .popover-item.selected .popover-check { display: block; }

        /* Rank & Status */
        .rank-trigger { display: flex; justify-content: center; align-items: center; width: 100%; padding: 14px; font-size: 0.8rem; font-weight: 700; border-radius: 10px; border: 1px solid transparent; background: var(--bg-modal-input); cursor: pointer; transition: all 0.2s; color: var(--text-main); }
        .rank-trigger:hover { background: rgba(0,0,0,0.05); } .dark .rank-trigger:hover { background: rgba(255,255,255,0.1); }
        .text-S { color: #ffb340; text-shadow: 0 0 15px rgba(255, 179, 64, 0.4); } .text-A { color: #8e8e93; } .text-B { color: #ae5622; } .text-C { color: #636366; }
        .rank-menu { position: absolute; width: 100%; z-index: 60; background: rgba(255, 255, 255, 0.9); backdrop-filter: blur(20px); border-radius: 12px; box-shadow: 0 20px 50px rgba(0,0,0,0.2); margin-top: 8px; display: none; overflow: hidden; text-align: center; border: 1px solid rgba(0,0,0,0.05); }
        .dark .rank-menu { background: rgba(44, 44, 46, 0.9); border-color: rgba(255,255,255,0.1); }
        .rank-menu.open { display: block; animation: popIn 0.2s cubic-bezier(0.2, 0.8, 0.2, 1) forwards; }
        .rank-option { padding: 14px; font-size: 0.75rem; font-weight: 600; cursor: pointer; border-bottom: 1px solid rgba(0,0,0,0.05); transition: background 0.1s; display: flex; justify-content: center; align-items: center; gap: 8px; color: var(--text-main); }
        .dark .rank-option { border-color: rgba(255,255,255,0.05); }
        .rank-option:hover { background: rgba(var(--accent-rgb), 0.1); }
        
        .status-segment { display: grid; grid-template-columns: repeat(3, 1fr); background: #e5e5ea; border-radius: 10px; padding: 4px; height: 40px; }
        .dark .status-segment { background: #2c2c2e; }
        .status-tab { display: flex; align-items: center; justify-content: center; font-size: 0.65rem; font-weight: 600; color: #8e8e93; cursor: pointer; border-radius: 7px; transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1); }
        .status-tab:active { transform: scale(0.95); }
        .status-tab.active { background: #fff; color: #000; box-shadow: 0 2px 6px rgba(0,0,0,0.1); }
        .dark .status-tab.active { background: #636366; color: #fff; }
        .status-tab.active[data-val="reading"] { color: var(--accent-color); } .dark .status-tab.active[data-val="reading"] { color: #fff; background: var(--accent-color); }
        .status-tab.active[data-val="completed"] { color: #32d74b; } .dark .status-tab.active[data-val="completed"] { color: #fff; background: #32d74b; }

        /* Others */
        .donut-chart { position: relative; width: 140px; height: 140px; border-radius: 50%; margin: 0 auto; display: flex; align-items: center; justify-content: center; }
        .donut-inner { width: 90px; height: 90px; background: #fff; border-radius: 50%; display: flex; flex-direction: column; align-items: center; justify-content: center; box-shadow: inset 0 2px 10px rgba(0,0,0,0.05); }
        .dark .donut-inner { background: #1c1c1e; box-shadow: inset 0 2px 10px rgba(0,0,0,0.3); }
        .kanban-col { min-height: calc(100vh - 200px); }
        .timeline-container { position: relative; padding-left: 2.5rem; }
        .timeline-line { position: absolute; left: 18px; top: 0; bottom: 0; width: 2px; background: #e5e5ea; }
        .dark .timeline-line { background: #2c2c2e; }
        .timeline-dot { position: absolute; left: 12px; top: 1.5rem; width: 14px; height: 14px; border-radius: 50%; background: #fff; border: 3px solid #d1d1d6; z-index: 10; box-shadow: 0 0 0 4px rgba(255,255,255,0.5); }
        .dark .timeline-dot { background: #000; border-color: #3a3a3c; box-shadow: 0 0 0 4px rgba(0,0,0,0.5); }
        .timeline-header { position: sticky; top: 0; z-index: 20; background: rgba(255,255,255,0.8); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); padding: 0.8rem 0; margin-bottom: 1rem; margin-left: -2.5rem; padding-left: 2.5rem; border-bottom: 1px solid rgba(0,0,0,0.05); }
        .dark .timeline-header { background: rgba(0,0,0,0.8); border-color: rgba(255,255,255,0.1); }
        .toast { position: fixed; bottom: 30px; right: 50%; transform: translateX(50%) translateY(20px); background: rgba(0,0,0,0.8); backdrop-filter: blur(10px); color: white; padding: 12px 24px; border-radius: 30px; font-size: 0.8rem; font-weight: 600; z-index: 99999; opacity: 0; pointer-events: none; transition: 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); box-shadow: 0 10px 30px rgba(0,0,0,0.2); white-space: nowrap; }
        .toast.show { opacity: 1; transform: translateX(50%) translateY(0); }
        #loadingOverlay { position: fixed; inset: 0; background: rgba(255,255,255,0.8); backdrop-filter: blur(5px); z-index: 999999; display: flex; align-items: center; justify-content: center; opacity: 0; pointer-events: none; transition: 0.3s; }
        .dark #loadingOverlay { background: rgba(0,0,0,0.7); }
        #loadingOverlay.active { opacity: 1; pointer-events: auto; }
        .img-edit-btn { position: absolute; top: 10px; right: 10px; width: 32px; height: 32px; border-radius: 50%; background: rgba(255,255,255,0.9); backdrop-filter: blur(4px); color: #1d1d1f; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 12px rgba(0,0,0,0.15); cursor: pointer; z-index: 30; transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1); }
        .img-edit-btn:active { transform: scale(0.85); }
        .dark .img-edit-btn { background: rgba(44, 44, 46, 0.9); color: white; }
        @keyframes popIn { from { opacity: 0; transform: translateY(-8px) scale(0.95); } to { opacity: 1; transform: translateY(0) scale(1); } }

        /* Security & Compliance UI (V51 Modified) */
        #backup-warning-bar { 
            position: fixed; 
            bottom: 30px; 
            left: 50%; 
            transform: translateX(-50%) translateY(40px) scale(0.95); 
            width: 92%; 
            max-width: 600px; 
            background: rgba(28, 28, 30, 0.85); 
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            color: #fff; 
            z-index: 9999; 
            padding: 16px 24px; 
            border-radius: 20px;
            font-size: 0.75rem; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            box-shadow: 0 20px 50px rgba(0,0,0,0.4);
            opacity: 0; 
            pointer-events: none;
            transition: all 0.6s cubic-bezier(0.19, 1, 0.22, 1); 
            border: 1px solid rgba(255,255,255,0.1);
        }
        #backup-warning-bar.visible { 
            transform: translateX(-50%) translateY(0) scale(1); 
            opacity: 1; 
            pointer-events: auto;
        }
        .dark #backup-warning-bar { 
            background: rgba(44, 44, 46, 0.85); 
        }
        .legal-modal-content { font-size: 0.85rem; line-height: 1.7; color: #3a3a3c; }
        .dark .legal-modal-content { color: #aeaeb2; }
/* === 10000% Magic Marker UI/UX === */
/* マーカーを引く際のアニメーション */
@keyframes marker-sweep {
    0% { background-size: 0% 100%; }
    100% { background-size: 100% 100%; }
}

/* 既存のマーカーのスタイルを上書きしてアニメーションと改行対応を追加 */
[class^="marker-"] {
    background-image: linear-gradient(transparent 60%, var(--m-color) 60%) !important;
    background-color: transparent !important;
    background-repeat: no-repeat !important;
    background-size: 100% 100% !important;
    animation: marker-sweep 0.35s cubic-bezier(0.2, 0.8, 0.2, 1) forwards !important;
    padding: 2px 2px !important;
    border-radius: 4px !important;
    -webkit-box-decoration-break: clone !important;
    box-decoration-break: clone !important;
}

/* 選択時に浮かび上がるiOS風マジックポップオーバー */
.magic-selection-popover {
    position: absolute;
    z-index: 100000;
    display: flex;
    gap: 10px;
    padding: 8px 12px;
    background: rgba(255, 255, 255, 0.75);
    backdrop-filter: blur(30px) saturate(200%);
    -webkit-backdrop-filter: blur(30px) saturate(200%);
    border: 1px solid rgba(255, 255, 255, 0.4);
    border-radius: 999px;
    box-shadow: 0 12px 40px rgba(0,0,0,0.15), 0 4px 12px rgba(0,0,0,0.08);
    opacity: 0;
    transform: translateY(10px) scale(0.9);
    pointer-events: none;
    transition: opacity 0.25s cubic-bezier(0.2, 0.8, 0.2, 1), transform 0.25s cubic-bezier(0.2, 0.8, 0.2, 1);
}

.dark .magic-selection-popover {
    background: rgba(30, 30, 32, 0.75);
    border-color: rgba(255, 255, 255, 0.1);
    box-shadow: 0 12px 40px rgba(0,0,0,0.5), 0 4px 12px rgba(0,0,0,0.3);
}

.magic-selection-popover.show {
    opacity: 1;
    transform: translateY(0) scale(1);
    pointer-events: auto;
}

/* ポップオーバーの下の三角形（吹き出し） */
.magic-selection-popover::after {
    content: '';
    position: absolute;
    bottom: -6px;
    left: 50%;
    transform: translateX(-50%);
    border-width: 6px 6px 0;
    border-style: solid;
    border-color: rgba(255, 255, 255, 0.75) transparent transparent transparent;
}
.dark .magic-selection-popover::after {
    border-color: rgba(30, 30, 32, 0.75) transparent transparent transparent;
}

.magic-gem {
    width: 26px;
    height: 26px;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid rgba(255,255,255,0.6);
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    transition: transform 0.25s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.2s;
}

.magic-gem:hover {
    transform: scale(1.3) translateY(-3px);
    box-shadow: 0 8px 16px rgba(0,0,0,0.25);
}
.dark .magic-gem { border-color: rgba(255,255,255,0.2); }
/* === 10000% Perfected Fluid Rank Segmented Control === */
/* 既存のドロップダウンを完全に非表示 */
#rank-trigger, #rank-menu { display: none !important; }

/* トラック（背景）のゆとりと美しさを最適化 */
.magic-rank-track {
    display: flex;
    align-items: center;
    position: relative;
    background: rgba(118, 118, 128, 0.12); /* Apple標準のセグメント背景 */
    border-radius: 12px;
    padding: 4px;
    height: 44px; /* 指でタップしやすいゆとりのある高さ */
    margin-top: 6px;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
}
.dark .magic-rank-track {
    background: rgba(118, 118, 128, 0.24);
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
}

/* ヌルッと動く魔法のインジケーター */
.magic-rank-indicator {
    position: absolute;
    top: 4px;
    left: 0;
    height: calc(100% - 8px);
    border-radius: 8px;
    background: #fff;
    box-shadow: 0 3px 8px rgba(0,0,0,0.12), 0 3px 1px rgba(0,0,0,0.04);
    /* transformとwidthで移動するため、絶対にズレない */
    transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1), width 0.4s cubic-bezier(0.2, 0.8, 0.2, 1), background 0.4s ease, box-shadow 0.4s ease;
    z-index: 1;
}
.dark .magic-rank-indicator {
    background: #636366;
    box-shadow: 0 3px 8px rgba(0,0,0,0.3), 0 3px 1px rgba(0,0,0,0.2);
}

/* 各ランクのテキスト要素 */
.magic-rank-item {
    position: relative;
    flex: 1;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.85rem;
    font-weight: 700;
    color: #8e8e93;
    z-index: 2;
    cursor: pointer;
    transition: color 0.3s ease;
    user-select: none;
}

/* 「未評価」は文字数が多いため、専用に横幅の比率を広げて窮屈さを無くす */
.magic-rank-item[data-rank=""] {
    flex: 1.5;
    font-size: 0.75rem;
}

/* 選択された時のテキストカラー（インジケーターに重なった際に読みやすくする） */
.magic-rank-item.is-active[data-rank=""] { color: var(--text-main); }
.magic-rank-item.is-active[data-rank="C"] { color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.2); }
.magic-rank-item.is-active[data-rank="B"] { color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.2); }
.magic-rank-item.is-active[data-rank="A"] { color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.2); }
.magic-rank-item.is-active[data-rank="S"] { color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.2); }

/* ランクに応じたインジケーターのグラデーション発光 */
.magic-rank-indicator.glow-none { background: #fff; }
.dark .magic-rank-indicator.glow-none { background: #636366; }
.magic-rank-indicator.glow-C { background: linear-gradient(135deg, #a1a1aa, #71717a); }
.magic-rank-indicator.glow-B { background: linear-gradient(135deg, #f97316, #c2410c); }
.magic-rank-indicator.glow-A { background: linear-gradient(135deg, #cbd5e1, #94a3b8); }
.magic-rank-indicator.glow-S { background: linear-gradient(135deg, #facc15, #f59e0b); box-shadow: 0 4px 15px rgba(250, 204, 21, 0.4); }

/* Sランク選択時のフレアエフェクト */
@keyframes s-rank-pop {
    0% { transform: scale(0.9); opacity: 0.8; }
    100% { transform: scale(1.8); opacity: 0; }
}
.s-rank-flare {
    position: absolute;
    inset: 0;
    border-radius: 8px;
    background: rgba(250, 204, 21, 0.5);
    animation: s-rank-pop 0.6s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
    z-index: 0;
    pointer-events: none;
}    
/* === 10000% Pro Sort Menu UI === */

/* 新しいリッチポップオーバーの基盤 */
#popover-sort {
    width: 240px;
    padding: 8px;
    border-radius: 16px !important;
}

/* カテゴリ見出し */
.sort-section-title {
    font-size: 0.65rem;
    font-weight: 800;
    color: #8e8e93;
    margin: 12px 12px 4px 12px;
    text-transform: uppercase;
    letter-spacing: 0.05em;
}
.sort-section-title:first-child { margin-top: 4px; }

/* 進化したソートアイテム */
.sort-pro-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 12px;
    margin-bottom: 2px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 0.8rem;
    font-weight: 600;
    color: var(--text-main);
    transition: background 0.15s ease, transform 0.1s cubic-bezier(0.2, 0.8, 0.2, 1);
}
.dark .sort-pro-item { color: #f5f5f7; }

/* 押下時の吸い付き（Haptic連携） */
.sort-pro-item:active { transform: scale(0.96); }

/* ホバー時の美しいハイライト */
.sort-pro-item:hover { background: rgba(0, 122, 255, 0.1); }
.dark .sort-pro-item:hover { background: rgba(10, 132, 255, 0.2); }

/* 選択中のスタイル（iOSのブルー強調） */
.sort-pro-item.is-selected { background: var(--accent-color) !important; color: #fff !important; }
.sort-pro-item.is-selected svg { stroke: #fff; opacity: 1; }
.sort-pro-item.is-selected .popover-check { display: block; color: #fff; }

/* 左側のアイコンとラベルのグループ */
.sort-label-group { display: flex; align-items: center; gap: 10px; }
.sort-label-group svg {
    width: 18px; height: 18px;
    stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; fill: none;
    opacity: 0.5;
    transition: opacity 0.2s;
}
.popover-check { display: none; font-weight: 800; }
/* === 10000% Pro Filter Menu UI === */

#popover-filter {
    width: 220px;
    padding: 8px;
    border-radius: 16px !important;
}

/* フィルターアイテムの基本スタイル */
.filter-pro-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 12px;
    margin-bottom: 2px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 0.8rem;
    font-weight: 600;
    color: var(--text-main);
    transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
}
.dark .filter-pro-item { color: #f5f5f7; }

/* 押下時の吸い付き（Haptic連携） */
.filter-pro-item:active { transform: scale(0.96); }

/* ホバー時の控えめなハイライト */
.filter-pro-item:hover { background: rgba(0,0,0,0.05); }
.dark .filter-pro-item:hover { background: rgba(255,255,255,0.1); }

/* アイコンとテキストのグループ */
.filter-label-group { display: flex; align-items: center; gap: 10px; }
.filter-label-group svg {
    width: 18px; height: 18px;
    stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; fill: none;
    opacity: 0.5;
    transition: opacity 0.2s;
}

/* 右端のリアルタイムカウントバッジ */
.filter-badge {
    font-size: 0.65rem;
    font-weight: 800;
    padding: 2px 8px;
    border-radius: 10px;
    background: rgba(0,0,0,0.08);
    color: #8e8e93;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    transition: all 0.2s;
}
.dark .filter-badge { background: rgba(255,255,255,0.1); }

/* === 選択中（Active）のステータス別カラーリング === */
.filter-pro-item.is-selected { color: #fff !important; }
.filter-pro-item.is-selected svg { stroke: #fff; opacity: 1; }
/* バッジの色も白ベースの半透明に反転 */
.filter-pro-item.is-selected .filter-badge { background: rgba(255,255,255,0.3); color: #fff; }

/* 選択項目の背景色をステータスに合わせる */
.filter-pro-item.is-selected[data-filter="all"] { background: #636366 !important; }
.filter-pro-item.is-selected[data-filter="unread"] { background: #8e8e93 !important; }
.filter-pro-item.is-selected[data-filter="reading"] { background: var(--accent-color) !important; }
.filter-pro-item.is-selected[data-filter="completed"] { background: #32d74b !important; }
/* === 10000% Pro Settings Menu UI === */

/* メニュー本体の質感をAppleのコントロールセンター風に超強化 */
#settingsMenu {
    width: 340px !important;
    max-width: 85vw !important; /* スマホでもはみ出さないように */
    background: rgba(242, 242, 247, 0.85) !important;
    backdrop-filter: blur(40px) saturate(200%) !important;
    -webkit-backdrop-filter: blur(40px) saturate(200%) !important;
    border-left: 1px solid rgba(0,0,0,0.05) !important;
    /* Apple特有の重厚で滑らかなイージング */
    transition: transform 0.5s cubic-bezier(0.32, 0.72, 0, 1) !important;
    z-index: 100000 !important;
}
.dark #settingsMenu {
    background: rgba(28, 28, 30, 0.85) !important;
    border-left: 1px solid rgba(255,255,255,0.1) !important;
}

/* メニューの背後に敷くフォーカス用オーバーレイ */
#settings-overlay {
    position: fixed;
    inset: 0;
    z-index: 99999;
    background: rgba(0,0,0,0.3);
    backdrop-filter: blur(2px);
    -webkit-backdrop-filter: blur(2px);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
}
#settings-overlay.show {
    opacity: 1;
    pointer-events: auto;
}

/* iOS風の角丸グループカード */
.menu-card {
    background: #fff;
    border-radius: 14px;
    margin-bottom: 24px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.03), 0 1px 3px rgba(0,0,0,0.02);
    overflow: hidden;
}
.dark .menu-card { 
    background: #1c1c1e; 
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
}

/* 統計リストの行 */
.menu-stat-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 14px 16px;
    border-bottom: 1px solid rgba(0,0,0,0.05);
    font-size: 0.85rem;
    font-weight: 700;
    color: var(--text-main);
}
.dark .menu-stat-row { border-bottom-color: rgba(255,255,255,0.05); }
.menu-stat-row:last-child { border-bottom: none; }

/* ボタン類（iOSのリストボタン風） */
.menu-action-btn {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    padding: 16px 16px;
    font-size: 0.85rem;
    font-weight: 700;
    color: var(--accent-color);
    background: transparent;
    border: none;
    cursor: pointer;
    border-bottom: 1px solid rgba(0,0,0,0.05);
    transition: background 0.2s;
}
.dark .menu-action-btn { border-bottom-color: rgba(255,255,255,0.05); }
.menu-action-btn:last-child { border-bottom: none; }
.menu-action-btn:active { background: rgba(0,0,0,0.05); }
.dark .menu-action-btn:active { background: rgba(255,255,255,0.1); }

/* === 10000% Pro Writing & Zen Mode UI === */

/* 1. シネマティック・フォーカス（タップ時に手前に浮き上がる） */
.rich-editor-wrapper {
    transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1), box-shadow 0.4s cubic-bezier(0.2, 0.8, 0.2, 1), border-color 0.4s ease !important;
    will-change: transform, box-shadow;
}
.rich-editor-wrapper:focus-within {
    transform: scale(1.02) translateY(-2px);
    box-shadow: 0 20px 40px rgba(0,0,0,0.08), 0 0 0 2px rgba(var(--accent-rgb), 0.2) !important;
    z-index: 50;
}
.dark .rich-editor-wrapper:focus-within {
    box-shadow: 0 20px 40px rgba(0,0,0,0.5), 0 0 0 2px rgba(var(--accent-rgb), 0.4) !important;
}

/* 2. インテリジェント・ゴーストプレースホルダー */
.rich-content:empty::before {
    pointer-events: none;
    color: #a1a1aa;
    font-weight: 500;
    font-size: 0.85rem;
    opacity: 0.8;
    transition: opacity 0.2s;
    line-height: 1.8;
}
.rich-content:focus::before { opacity: 0.3; } /* 書き始めようとすると控えめに退避 */

/* 3. 究極のZen Mode（Ulysses / Apple Pages風） */
#zenOverlay {
    background: rgba(255, 255, 255, 0.95) !important;
    backdrop-filter: blur(40px) saturate(200%) !important;
    -webkit-backdrop-filter: blur(40px) saturate(200%) !important;
    transition: opacity 0.6s cubic-bezier(0.2, 0.8, 0.2, 1) !important;
}
.dark #zenOverlay { background: rgba(28, 28, 30, 0.95) !important; }

.zen-textarea {
    font-family: "Yu Mincho", "Hiragino Mincho ProN", "Noto Serif JP", serif !important;
    font-size: 1.25rem !important;
    line-height: 2.2 !important;
    letter-spacing: 0.05em !important;
    padding: 6rem 2rem !important; /* ゆとりのある余白 */
    max-width: 700px !important; /* 人間が最も読みやすい1行の長さに制限 */
    margin: 0 auto;
    text-align: justify;
    transition: color 0.3s;
}
.zen-textarea::placeholder { color: #d4d4d8; font-weight: 300; }
.dark .zen-textarea::placeholder { color: #52525b; }

/* Zen Mode: 美しいHUD風閉じるボタン */
.zen-close-btn {
    top: 2rem !important; right: 2rem !important;
    background: rgba(0,0,0,0.05);
    padding: 8px 16px;
    border-radius: 999px;
    font-size: 0.75rem;
    font-family: ui-sans-serif, system-ui, sans-serif;
    font-weight: 700;
    letter-spacing: 0.05em;
    backdrop-filter: blur(10px);
    transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
}
.dark .zen-close-btn { background: rgba(255,255,255,0.1); color: #fff; }
.zen-close-btn:hover { transform: scale(1.05); background: rgba(0,0,0,0.1); }
.dark .zen-close-btn:hover { background: rgba(255,255,255,0.2); }

/* Zen Mode: ライブ文字数カウンター */
.zen-char-counter {
    position: absolute;
    bottom: 2rem;
    left: 50%;
    transform: translateX(-50%);
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    font-size: 0.75rem;
    font-weight: 700;
    color: #8e8e93;
    background: rgba(142, 142, 147, 0.1);
    padding: 6px 16px;
    border-radius: 999px;
    letter-spacing: 0.05em;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
    box-shadow: 0 4px 12px rgba(0,0,0,0.05);
}
.zen-char-counter.show { opacity: 1; }

/* === KANBAN機能の完全消去（引き算のデザイン） === */
#tab-pc-kanban, 
#tab-mb-kanban, 
#view-content-kanban { 
    display: none !important; 
}

/* === 10000% Ultra-Compact Pro Menu UI === */

/* メニュー本体を極限までスリム化し、より強いすりガラスに */
#settingsMenu {
    width: 280px !important;
    background: rgba(250, 250, 250, 0.65) !important;
    backdrop-filter: blur(50px) saturate(200%) !important;
    -webkit-backdrop-filter: blur(50px) saturate(200%) !important;
}
.dark #settingsMenu {
    background: rgba(28, 28, 30, 0.65) !important;
}

/* タイトに詰まった美しいカード型UI */
.compact-menu-card {
    background: rgba(255, 255, 255, 0.6);
    border-radius: 12px;
    margin-bottom: 16px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.02), inset 0 0 0 1px rgba(255,255,255,0.4);
    overflow: hidden;
}
.dark .compact-menu-card { 
    background: rgba(0, 0, 0, 0.25); 
    box-shadow: 0 2px 10px rgba(0,0,0,0.2), inset 0 0 0 1px rgba(255,255,255,0.05);
}

/* 統計リストの行（文字を小さく・ハッキリと） */
.compact-stat-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 14px;
    border-bottom: 1px solid rgba(0,0,0,0.04);
    font-size: 0.75rem; /* 小さくして視認性を高める */
    font-weight: 700;
    color: var(--text-main);
}
.dark .compact-stat-row { border-bottom-color: rgba(255,255,255,0.04); }
.compact-stat-row:last-child { border-bottom: none; }

/* ボタン類（コンパクトで密度高く） */
.compact-action-btn {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    padding: 12px 14px;
    font-size: 0.75rem;
    font-weight: 700;
    color: var(--accent-color);
    background: transparent;
    border: none;
    cursor: pointer;
    border-bottom: 1px solid rgba(0,0,0,0.04);
    transition: background 0.2s;
}
.dark .compact-action-btn { border-bottom-color: rgba(255,255,255,0.04); }
.compact-action-btn:last-child { border-bottom: none; }
.compact-action-btn:active { background: rgba(0,0,0,0.05); }
.dark .compact-action-btn:active { background: rgba(255,255,255,0.1); }

/* ドーナツチャートの小型化（75%縮小してスッキリ） */
.compact-donut-wrapper {
    transform: scale(0.75);
    margin: -10px auto;
}
/* === 10000% Dynamic Island Tabs UI === */

/* PC版のコンテナをKANBAN消去に合わせてスタイリッシュに引き締め */
.hidden.md\:block .liquid-nav-container {
    width: 320px !important; 
}

/* ナビコンテナを丸みのあるピル形状に */
.liquid-nav-container {
    border-radius: 999px !important;
    padding: 4px !important;
    height: 42px !important;
    box-shadow: inset 0 1px 4px rgba(0,0,0,0.05) !important;
    background: rgba(118, 118, 128, 0.08) !important;
}
.dark .liquid-nav-container {
    background: rgba(118, 118, 128, 0.24) !important;
    box-shadow: inset 0 1px 4px rgba(0,0,0,0.4) !important;
}

/* 動くハイライター（背景）の質感をガラス風に強化 */
.liquid-highlighter {
    border-radius: 999px !important;
    background: #ffffff !important;
    box-shadow: 0 2px 8px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.05) !important;
}
.dark .liquid-highlighter {
    background: #3a3a3c !important;
    box-shadow: 0 2px 8px rgba(0,0,0,0.4), 0 1px 2px rgba(0,0,0,0.2) !important;
}

/* タブのベーススタイル */
.liquid-tab {
    border-radius: 999px !important;
    color: #a1a1aa !important;
}
.dark .liquid-tab { color: #8e8e93 !important; }

/* 内部コンテンツの流体アニメーションコンテナ */
.tab-inner {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    /* 非アクティブ時は文字が消えるため、アイコンが中央にくるように右へずらす */
    transform: translateX(12px); 
    transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
}

/* 専用SVGアイコンのスタイル */
.liquid-tab svg {
    width: 16px; height: 16px;
    stroke: currentColor; stroke-width: 2.5; fill: none; stroke-linecap: round; stroke-linejoin: round;
    transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1), stroke 0.4s ease;
}

/* タブのテキストラベル（通常時は透明・縮小状態） */
.tab-label {
    opacity: 0;
    transform: translateX(-8px) scale(0.95);
    transition: all 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
    font-size: 0.65rem;
    font-weight: 800;
    letter-spacing: 0.05em;
    pointer-events: none;
}

/* === アクティブ状態のアニメーション === */
.liquid-tab.active .tab-inner {
    transform: translateX(0); /* ずらしを解除し、本来の配置へ戻す */
}
.liquid-tab.active .tab-label {
    opacity: 1;
    transform: translateX(0) scale(1); /* 右からスッと文字が浮き出る */
    color: var(--text-main);
}
.liquid-tab.active svg {
    stroke: var(--accent-color) !important; /* アイコンがテーマカラーに光る */
    transform: scale(1.1); /* アイコンが少し強調される */
}

/* === 10000% Pro Living Logo UI === */

/* ロゴコンテナのアクティブ（押下）アニメーション */
.pro-logo-wrapper {
    transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    transform-origin: left center;
}
.pro-logo-wrapper:active {
    transform: scale(0.92);
}

/* 3D展開する魔法のアイコンコンテナ */
.pro-logo-icon {
    position: relative;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    perspective: 1000px; /* 3D空間の定義 */
    margin-right: 4px;
}

/* ページ（レイヤー）の基本スタイル */
.pro-logo-layer {
    position: absolute;
    border-radius: 4px;
    transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

/* 背面のレイヤー（アクセントカラー・淡） */
.pro-logo-layer-1 {
    width: 14px; height: 18px;
    background: var(--accent-color);
    opacity: 0.2;
    transform: rotate(-12deg) translateX(-3px) scale(0.9);
}
.dark .pro-logo-layer-1 { opacity: 0.4; }

/* 中間のレイヤー（アクセントカラー・濃） */
.pro-logo-layer-2 {
    width: 14px; height: 18px;
    background: var(--accent-color);
    opacity: 0.6;
    transform: rotate(-6deg) translateX(-1px) scale(0.95);
}

/* 前面のレイヤー（メインカラー） */
.pro-logo-layer-3 {
    width: 14px; height: 18px;
    background: var(--text-main);
    z-index: 10;
    box-shadow: 0 4px 10px rgba(0,0,0,0.15);
}

/* === ホバー時の3D展開アニメーション === */
.flex.items-center.cursor-pointer:hover .pro-logo-layer-1 { 
    transform: rotate(-24deg) translateX(-7px) scale(1.05); 
    opacity: 0.4; 
}
.flex.items-center.cursor-pointer:hover .pro-logo-layer-2 { 
    transform: rotate(-12deg) translateX(-3px) scale(1.05); 
    opacity: 0.8; 
}
.flex.items-center.cursor-pointer:hover .pro-logo-layer-3 { 
    transform: rotate(0deg) scale(1.05); 
}

/* チタンのような光沢を放つテキストグラデーション */
.pro-logo-text {
    font-size: 0.9rem;
    font-weight: 900;
    letter-spacing: 0.15em;
    background: linear-gradient(135deg, var(--text-main) 0%, #a1a1aa 40%, var(--text-main) 80%);
    background-size: 200% auto;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    transition: background-position 0.6s cubic-bezier(0.2, 0.8, 0.2, 1);
}

/* ホバー時に光が流れるエフェクト */
.flex.items-center.cursor-pointer:hover .pro-logo-text {
    background-position: 100% center;
}

/* === 10000% Pro Timeline UI === */

/* タイムラインのコンテナと中心線の美化 */
.timeline-container { 
    position: relative; 
    padding-left: 3.5rem !important; 
    margin-top: 1rem; 
}
.timeline-line {
    position: absolute; 
    left: 24px !important; 
    top: 0; bottom: 0; 
    width: 3px !important;
    /* 上から下へ美しいグラデーションを描く時間軸 */
    background: linear-gradient(to bottom, transparent, var(--accent-color) 15%, #32d74b 85%, transparent) !important;
    opacity: 0.4; 
    border-radius: 3px;
}
.dark .timeline-line { opacity: 0.3; }

/* 吸着する（Sticky）美しいすりガラスの月別ヘッダー */
.timeline-header {
    position: sticky; 
    top: 60px; /* ヘッダーの下にピタッと止まる */
    z-index: 30;
    background: rgba(255, 255, 255, 0.6) !important;
    backdrop-filter: blur(20px) saturate(180%) !important;
    -webkit-backdrop-filter: blur(20px) saturate(180%) !important;
    padding: 8px 20px !important; 
    margin-left: -3.5rem !important; 
    border-radius: 14px; 
    border: 1px solid rgba(255,255,255,0.4);
    box-shadow: 0 4px 20px rgba(0,0,0,0.05);
    display: inline-flex; 
    align-items: baseline; 
    margin-bottom: 24px !important;
    transition: transform 0.3s;
}
.dark .timeline-header { 
    background: rgba(28, 28, 30, 0.6) !important; 
    border-color: rgba(255,255,255,0.05); 
}

/* タイムライン上のドット（状態に応じて色が変わり、ホバーで拡大する） */
.timeline-dot {
    position: absolute;
    left: 17px !important; 
    top: 2rem !important; 
    width: 16px !important; 
    height: 16px !important;
    border: 4px solid #fff !important; 
    border-radius: 50%;
    box-shadow: 0 0 0 3px rgba(0,0,0,0.03), 0 4px 10px rgba(0,0,0,0.15) !important;
    transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), background 0.3s !important;
    z-index: 10;
}
.dark .timeline-dot { 
    border-color: #1c1c1e !important; 
    box-shadow: 0 0 0 3px rgba(255,255,255,0.05), 0 4px 10px rgba(0,0,0,0.5) !important; 
}
.dot-unread { background: #8e8e93 !important; }
.dot-reading { background: var(--accent-color) !important; }
.dot-completed { background: #32d74b !important; }

/* タイムラインのカード */
.timeline-card {
    position: relative; 
    margin-bottom: 2rem !important; 
    margin-left: 1.5rem !important;
    background: #fff; 
    border-radius: 16px; 
    padding: 16px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.04), 0 1px 3px rgba(0,0,0,0.02);
    border: 1px solid rgba(0,0,0,0.02);
    display: flex; 
    gap: 16px; 
    cursor: pointer;
    transition: all 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
    /* 連続フェードイン用のアニメーション設定 */
    animation: timeline-slide-up 0.6s cubic-bezier(0.2, 0.8, 0.2, 1) both;
}
.dark .timeline-card { 
    background: #1c1c1e; 
    border-color: rgba(255,255,255,0.05); 
    box-shadow: 0 4px 20px rgba(0,0,0,0.3); 
}

/* カードホバー時の立体感強化と、ドットの連動拡大（group-hover） */
.group:hover .timeline-card {
    transform: translateY(-4px) scale(1.01);
    box-shadow: 0 12px 30px rgba(0,0,0,0.08), 0 4px 8px rgba(0,0,0,0.04);
}
.dark .group:hover .timeline-card { box-shadow: 0 12px 30px rgba(0,0,0,0.5); }
.group:hover .timeline-dot {
    transform: scale(1.4);
}

/* タイムライン専用のSランクなどのバッジ配置 */
.timeline-rank-badge {
    position: absolute; 
    right: 16px; 
    top: 16px;
    font-size: 0.65rem; 
    font-weight: 800; 
    padding: 3px 8px; 
    border-radius: 8px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
}

/* フェードインアニメーションのキーフレーム */
@keyframes timeline-slide-up {
    0% { opacity: 0; transform: translateY(30px) scale(0.98); }
    100% { opacity: 1; transform: translateY(0) scale(1); }
}

/* === 10000% Perfected Ultra-Compact Tabs === */

/* 1. 全体サイズを極限までコンパクトに（320px → 250px へ大幅スリム化） */
.hidden.md\:block .liquid-nav-container {
    width: 250px !important;
}
.liquid-nav-container {
    height: 34px !important; /* 42px → 34px へシャープに */
    padding: 3px !important;
}

/* 2. 前回の位置ズレの原因（transform）を完全排除 */
.tab-inner {
    transform: none !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
}

/* 3. アイコンを少し小さくし、Apple Watchのようなプロ仕様の比率へ */
.liquid-tab svg {
    width: 14px !important;
    height: 14px !important;
    stroke-width: 2.2 !important; /* 少し細くして上品に */
}

/* 4. テキストを「幅0」で隠すことで、非アクティブ時はアイコンを【完全に中央】へ配置 */
.tab-label {
    transform: none !important; /* スライド移動を廃止 */
    max-width: 0 !important;
    margin-left: 0 !important;
    opacity: 0 !important;
    font-size: 0.55rem !important; /* テキストを限界まで小さく美しく */
    overflow: hidden !important;
    transition: max-width 0.4s cubic-bezier(0.2, 0.8, 0.2, 1), margin-left 0.4s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.3s ease !important;
}

/* 5. アクティブ時に幅を広げ、中央から均等に展開させる（絶対にズレない） */
.liquid-tab.active .tab-label {
    max-width: 60px !important; /* TIMELINEの文字が収まる幅 */
    margin-left: 4px !important;
    opacity: 1 !important;
}

/* === 10000% Ultra-Pro Magnetic Logo === */

/* マグネティック（磁力）アニメーションの基盤コンテナ */
.magnetic-logo-wrapper {
    position: relative;
    display: flex;
    align-items: center;
    padding: 6px 12px;
    margin-left: -12px; /* 余白分を相殺して元の位置をキープ */
    border-radius: 12px;
    /* マウスが離れた時に「スッ」と戻る滑らかなイージング */
    transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
    transform-style: preserve-3d;
    cursor: pointer;
    z-index: 50;
}

/* ロゴの背後に潜む「液状の光のオーラ」 */
.magnetic-logo-aura {
    position: absolute;
    inset: 0;
    border-radius: 12px;
    background: radial-gradient(circle at 50% 50%, rgba(var(--accent-rgb), 0.2), transparent 70%);
    opacity: 0;
    filter: blur(8px);
    transition: opacity 0.5s ease;
    pointer-events: none;
    z-index: 0;
}
/* ホバー時にオーラが鼓動（パルス）し始める */
.magnetic-logo-wrapper:hover .magnetic-logo-aura {
    opacity: 1;
    animation: liquid-aura-pulse 3s infinite alternate ease-in-out;
}

@keyframes liquid-aura-pulse {
    0% { transform: scale(0.8) translate(0, 0); }
    100% { transform: scale(1.3) translate(2px, -2px); }
}

/* アイコンとテキストのコンテナ */
.magnetic-logo-content {
    display: flex;
    align-items: center;
    gap: 8px;
    z-index: 1;
    pointer-events: none; /* マウスイベントの邪魔をさせない */
}

/* 本の形をしたミニマルで極上のSVGアイコン */
.magnetic-logo-icon-svg {
    width: 18px;
    height: 18px;
    color: var(--text-main);
    transition: transform 0.5s cubic-bezier(0.2, 0.8, 0.2, 1), color 0.3s ease;
}
/* ホバーするとアイコンが斜めに傾き、アクセントカラーに輝く */
.magnetic-logo-wrapper:hover .magnetic-logo-icon-svg {
    transform: rotate(-12deg) scale(1.15) translateY(-1px);
    color: var(--accent-color);
}

/* タイポグラフィの極限調整（文字間隔と金属質のグラデーション） */
.magnetic-logo-text {
    font-size: 0.85rem;
    font-weight: 900;
    letter-spacing: 0.2em; /* 文字間隔を広げてブランドロゴ感を強調 */
    background: linear-gradient(135deg, var(--text-main) 0%, #a1a1aa 50%, var(--text-main) 100%);
    background-size: 200% auto;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    transition: background-position 0.6s cubic-bezier(0.2, 0.8, 0.2, 1);
}
.magnetic-logo-wrapper:hover .magnetic-logo-text {
    background-position: 100% center;
}

/* === 10000% Spotlight Search UI === */

/* 1. 検索バー本体をiOSのSafari/Spotlight風に洗練 */
#searchInput, #localSearchInput {
    padding-left: 36px !important; /* 左の虫眼鏡アイコン用の余白 */
    border-radius: 999px !important;
    background: rgba(118, 118, 128, 0.08) !important;
    border: 1px solid transparent !important;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.05) !important;
    /* フォーカス時の滑らかな広がりと発光アニメーション */
    transition: all 0.4s cubic-bezier(0.2, 0.8, 0.2, 1) !important;
}
.dark #searchInput, .dark #localSearchInput {
    background: rgba(118, 118, 128, 0.24) !important;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.4) !important;
}

/* 検索バーにフォーカスした際の美しいGlow（発光）エフェクト */
#searchInput:focus, #localSearchInput:focus {
    background: #ffffff !important;
    box-shadow: 0 4px 15px rgba(0,0,0,0.05), 0 0 0 3px rgba(var(--accent-rgb), 0.2) !important;
    border-color: rgba(var(--accent-rgb), 0.4) !important;
}
.dark #searchInput:focus, .dark #localSearchInput:focus {
    background: #1c1c1e !important;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3), 0 0 0 3px rgba(var(--accent-rgb), 0.3) !important;
}

/* 2. Web検索結果のドロップダウンを極上のフローティングガラスパネルへ */
#searchResults {
    border-radius: 16px !important;
    box-shadow: 0 20px 40px rgba(0,0,0,0.15), 0 0 0 1px rgba(0,0,0,0.05) !important;
    background: rgba(255, 255, 255, 0.85) !important;
    backdrop-filter: blur(40px) saturate(200%) !important;
    -webkit-backdrop-filter: blur(40px) saturate(200%) !important;
    border: none !important;
    padding: 8px !important;
    /* 現れる際のポップインアニメーション */
    transform-origin: top center;
    animation: search-results-pop 0.3s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
}
.dark #searchResults {
    background: rgba(30, 30, 32, 0.85) !important;
    box-shadow: 0 20px 40px rgba(0,0,0,0.5), 0 0 0 1px rgba(255,255,255,0.1) !important;
}

@keyframes search-results-pop {
    0% { opacity: 0; transform: translateY(-10px) scale(0.98); }
    100% { opacity: 1; transform: translateY(0) scale(1); }
}

/* 3. 検索中...の代わりに表示されるスケルトンローダーのアニメーション */
.search-skeleton-pulse {
    animation: skeleton-wave 1.5s ease-in-out infinite;
}
@keyframes skeleton-wave {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.4; }
}

/* === 10000% Pro Dark Mode & Eclipse Transition === */

/* 1. 太陽と月のモーフィングアイコン */
.theme-toggle-icon {
    transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.4s ease;
    transform-origin: center;
}
/* ライトモード時（月を表示、太陽を待機） */
html:not(.dark) .theme-toggle-icon.moon { opacity: 1; transform: rotate(0deg) scale(1); }
html:not(.dark) .theme-toggle-icon.sun { opacity: 0; transform: rotate(90deg) scale(0); pointer-events: none; }

/* ダークモード時（太陽を表示、月を待機） */
html.dark .theme-toggle-icon.sun { opacity: 1; transform: rotate(0deg) scale(1); }
html.dark .theme-toggle-icon.moon { opacity: 0; transform: rotate(-90deg) scale(0); pointer-events: none; }

/* 2. 指先から広がるEclipse（日食）波紋エフェクト */
/* 既存のモーダル変形アニメーションに干渉しないよう、.theme-transitioning クラスが付与された時のみ発動 */
html.theme-transitioning::view-transition-group(root) {
    animation-duration: 0.8s;
    animation-timing-function: cubic-bezier(0.2, 0.8, 0.2, 1);
}

html.theme-transitioning::view-transition-new(root) {
    animation: theme-eclipse-reveal 0.8s cubic-bezier(0.25, 1, 0.5, 1) forwards;
    mix-blend-mode: normal;
    z-index: 9999999;
}

html.theme-transitioning::view-transition-old(root) {
    animation: none;
    z-index: -1;
}

/* クリックした座標（--theme-x, --theme-y）を中心に、計算された半径（--theme-r）まで円が広がる */
@keyframes theme-eclipse-reveal {
    from { clip-path: circle(0px at var(--theme-x) var(--theme-y)); }
    to { clip-path: circle(var(--theme-r) at var(--theme-x) var(--theme-y)); }
}

/* === 10000% Pro Local Bookshelf Search UI === */

/* 1. 流体拡張する検索バー */
#localSearchInput {
    padding-right: 46px !important; /* バッジやクリアボタン用の余白 */
    transition: width 0.4s cubic-bezier(0.2, 0.8, 0.2, 1), box-shadow 0.4s ease, background 0.4s ease, border-color 0.4s ease !important;
}
/* フォーカス時に滑らかに幅が広がり、存在感を増す */
#localSearchInput:focus {
    width: 240px !important;
}
@media (min-width: 768px) {
    #localSearchInput:focus { width: 340px !important; }
}

/* 2. プロツール感を引き立てる「⌘K」ショートカットバッジ */
.search-shortcut-badge {
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    background: rgba(142, 142, 147, 0.15);
    color: #8e8e93;
    font-size: 0.65rem;
    font-weight: 800;
    padding: 3px 6px;
    border-radius: 6px;
    pointer-events: none; /* クリックを邪魔しない */
    transition: opacity 0.3s cubic-bezier(0.2, 0.8, 0.2, 1), transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    z-index: 5;
}
.dark .search-shortcut-badge { 
    background: rgba(255,255,255,0.1); 
    color: #a1a1aa; 
}
/* 文字が入力されたらバッジを奥に引っ込めて隠す */
.search-shortcut-badge.hidden-badge {
    opacity: 0;
    transform: translateY(-50%) scale(0.8);
}

/* 3. リアルタイムにヒット数を知らせる「すりガラスのピル（Pill）」 */
.search-results-pill {
    position: absolute;
    bottom: -44px;
    right: 0;
    background: rgba(255, 255, 255, 0.85);
    backdrop-filter: blur(20px) saturate(200%);
    -webkit-backdrop-filter: blur(20px) saturate(200%);
    border: 1px solid rgba(0,0,0,0.05);
    padding: 8px 16px;
    border-radius: 999px;
    font-size: 0.75rem;
    font-weight: 800;
    color: var(--accent-color);
    box-shadow: 0 10px 30px rgba(0,0,0,0.1);
    opacity: 0;
    transform: translateY(10px) scale(0.9);
    pointer-events: none;
    transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    z-index: 50;
    white-space: nowrap;
}
.dark .search-results-pill {
    background: rgba(30, 30, 32, 0.85);
    border-color: rgba(255,255,255,0.1);
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
}
.search-results-pill.show {
    opacity: 1;
    transform: translateY(0) scale(1);
}

/* === 10000% Ultra-Premium Cinematic Boot & Spatial Cascade === */

/* 1. 極上の空間背景（ライト/ダーク対応） */
#cinematic-splash {
    position: fixed;
    inset: 0;
    z-index: 99999999;
    background: #fbfbfd; /* Appleの純白に近い上質なグレー */
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    transition: opacity 0.8s cubic-bezier(0.16, 1, 0.3, 1), backdrop-filter 0.8s ease;
}
.dark #cinematic-splash { background: #000000; }

/* 2. Apple Intelligence風の有機的なオーラ（Fluid Aurora） */
.splash-aura-container {
    position: absolute;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    animation: aura-fade-in 2.5s cubic-bezier(0.16, 1, 0.3, 1) forwards;
}

.splash-aura {
    width: 40vw;
    height: 40vw;
    min-width: 300px;
    min-height: 300px;
    background: radial-gradient(circle at 50% 50%, rgba(50, 150, 255, 0.5), rgba(180, 80, 230, 0.3) 40%, transparent 70%);
    filter: blur(50px);
    border-radius: 50%;
    animation: aura-morph 4s ease-in-out infinite alternate;
}
.dark .splash-aura {
    background: radial-gradient(circle at 50% 50%, rgba(10, 132, 255, 0.6), rgba(191, 90, 242, 0.4) 40%, transparent 70%);
    filter: blur(60px);
}

@keyframes aura-morph {
    0% { transform: scale(0.8) translate(-10px, 10px) rotate(0deg); border-radius: 40% 60% 70% 30%; }
    100% { transform: scale(1.2) translate(10px, -10px) rotate(180deg); border-radius: 60% 40% 30% 70%; }
}

@keyframes aura-fade-in {
    0% { opacity: 0; transform: scale(0.5); }
    30% { opacity: 1; transform: scale(1); }
    80% { opacity: 1; transform: scale(1.1); filter: blur(60px); }
    100% { opacity: 0; transform: scale(1.5); filter: blur(80px); }
}

/* 3. 洗練されたチタン/ガラス調のロゴ */
.splash-logo-core {
    position: relative;
    z-index: 10;
    font-size: 1.5rem;
    font-weight: 900;
    letter-spacing: 0.3em;
    color: #1d1d1f;
    opacity: 0;
    display: flex;
    align-items: center;
    gap: 12px;
    animation: premium-logo-reveal 2.2s cubic-bezier(0.16, 1, 0.3, 1) forwards;
}
.dark .splash-logo-core { color: #f5f5f7; }

@keyframes premium-logo-reveal {
    0% { opacity: 0; transform: translateY(10px) scale(0.95); filter: blur(8px); }
    25% { opacity: 1; transform: translateY(0) scale(1); filter: blur(0px); }
    75% { opacity: 1; transform: translateY(0) scale(1); filter: blur(0px); }
    100% { opacity: 0; transform: translateY(-10px) scale(1.05); filter: blur(10px); }
}

/* スプラッシュ全体が画面に溶けて消える */
#cinematic-splash.fade-out {
    opacity: 0;
    pointer-events: none;
    backdrop-filter: blur(0px);
}

/* 4. ヘッダーのドロップイン（より滑らかに） */
.header-cinematic-drop {
    animation: header-premium-drop 1s cubic-bezier(0.16, 1, 0.3, 1) both;
}
@keyframes header-premium-drop {
    0% { opacity: 0; transform: translateY(-20px); }
    100% { opacity: 1; transform: translateY(0); }
}

/* 5. 本のカードの極上カスケード（弾まずにスッと吸い付くAppleのイージング） */
.cinematic-card-enter {
    animation: spatial-cascade-premium 0.8s cubic-bezier(0.16, 1, 0.3, 1) both;
    will-change: transform, opacity, filter;
}
@keyframes spatial-cascade-premium {
    0% { opacity: 0; transform: translateY(20px) scale(0.98); filter: blur(8px); }
    100% { opacity: 1; transform: translateY(0) scale(1); filter: blur(0); }
}
</style>
</head>
<body class="bg-white text-gray-900 dark:bg-darkBg dark:text-gray-200 min-h-screen flex flex-col font-sans text-[13px] transition-colors duration-0" onclick="closePopovers(event)">

    <div id="zenOverlay"><div class="zen-close-btn haptic-tap" onclick="closeZenMode()">× 閉じる</div><textarea id="zenTextarea" class="zen-textarea" placeholder="ここに感想を書いてください..."></textarea></div>
    <div id="toast" class="toast"><span id="toastMsg">保存しました</span></div>
    <div id="loadingOverlay"><div class="animate-spin rounded-full h-8 w-8 border-b-2 border-accent mb-4"></div><p class="font-bold text-xs tracking-widest text-gray-500">LOADING...</p></div>
    <input type="file" id="coverUpload" accept="image/*" class="hidden" onchange="handleImageUpload(this)">
    
    <div id="popover-imgEdit" class="floating-popover">
        <div onclick="promptImageURL(); triggerHaptic();" class="popover-item">画像URLを貼付</div>
        <div onclick="document.getElementById('coverUpload').click(); triggerHaptic();" class="popover-item">画像をアップロード</div>
        <div onclick="resetImage(); triggerHaptic();" class="popover-item text-red-500">元に戻す</div>
    </div>

    <div id="backup-warning-bar">
        <div class="flex flex-col md:flex-row md:items-center gap-2">
            <span class="font-bold text-yellow-400">注意</span>
            <span>データはブラウザにのみ保存されます。キャッシュ削除等で消えるため、定期的にバックアップ(JSON)を保存してください。</span>
        </div>
        <button onclick="dismissBackupWarning(); triggerHaptic();" class="ml-4 px-4 py-1.5 bg-white text-black text-xs font-bold rounded-full hover:bg-gray-200 haptic-tap">OK</button>
    </div>

    <header class="sticky top-0 z-40 bg-white/80 dark:bg-black/80 backdrop-blur-xl border-b border-gray-100 dark:border-gray-800 transition-colors duration-500">
        <div class="w-full px-4 md:px-6 h-14 flex justify-between items-center">
            <div class="flex items-center space-x-2 select-none cursor-pointer haptic-tap" onclick="switchView('grid'); triggerHaptic();">
                <div class="w-4 h-4 bg-black dark:bg-white rounded-sm"></div>
                <h1 class="text-sm font-extrabold tracking-widest">BOOKLOG</span></h1>
            </div>
            <div class="hidden md:block">
                <div class="liquid-nav-container w-[400px]"> <div id="liquid-highlighter-pc" class="liquid-highlighter"></div>
                    <button onclick="switchView('grid'); triggerHaptic();" id="tab-pc-grid" class="liquid-tab active">GRID</button>
                    <button onclick="switchView('tag'); triggerHaptic();" id="tab-pc-tag" class="liquid-tab">TAG</button>
                    <button onclick="switchView('kanban'); triggerHaptic();" id="tab-pc-kanban" class="liquid-tab">KANBAN</button>
                    <button onclick="switchView('timeline'); triggerHaptic();" id="tab-pc-timeline" class="liquid-tab">TIMELINE</button>
                </div>
            </div>
            <div class="flex items-center space-x-2">
                <button onclick="toggleTheme(); triggerHaptic();" class="p-2.5 bg-gray-100 dark:bg-darkCard hover:bg-gray-200 dark:hover:bg-gray-700 rounded-smooth haptic-tap transition-colors"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg></button>
                <button onclick="toggleSettings(); triggerHaptic();" class="p-2.5 bg-gray-100 dark:bg-darkCard hover:bg-gray-200 dark:hover:bg-gray-700 rounded-smooth haptic-tap transition-colors"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"></path></svg></button>
            </div>
        </div>
        <div class="md:hidden px-4 pb-2">
            <div class="liquid-nav-container w-full">
                <div id="liquid-highlighter-mobile" class="liquid-highlighter"></div>
                <button onclick="switchView('grid'); triggerHaptic();" id="tab-mb-grid" class="liquid-tab active">GRID</button>
                <button onclick="switchView('tag'); triggerHaptic();" id="tab-mb-tag" class="liquid-tab">TAG</button>
                <button onclick="switchView('kanban'); triggerHaptic();" id="tab-mb-kanban" class="liquid-tab">KANBAN</button>
                <button onclick="switchView('timeline'); triggerHaptic();" id="tab-mb-timeline" class="liquid-tab">TIMELINE</button>
            </div>
        </div>
        <div class="w-full border-t border-gray-100 dark:border-gray-800 bg-gray-50/50 dark:bg-black/50 backdrop-blur-xl py-2 px-4 md:px-6 flex flex-col md:flex-row justify-between items-center gap-2 text-xs">
            <div class="relative w-full md:w-1/3">
                <div class="relative">
                    <input type="text" id="searchInput" placeholder="WEBから本を探す..." class="w-full liquid-glass rounded-smooth px-3 py-1.5 focus:border-accent text-gray-900 dark:text-gray-100 placeholder-gray-500 pr-8 transition-colors">
                    <button id="clearWebSearch" class="hidden absolute right-2 top-1.5 text-gray-400 hover:text-accent font-bold" onclick="clearWebSearch(); triggerHaptic();">×</button>
                </div>
                <div class="text-[9px] text-gray-400 mt-1 ml-1 font-sans">Powered by Google Books API</div>

                <div id="searchResults" class="absolute w-full bg-white dark:bg-darkCard border border-gray-200 dark:border-gray-700 shadow-apple-float z-50 max-h-[70vh] overflow-y-auto hidden top-full left-0 mt-2 rounded-smooth"></div>
            </div>
            <div class="flex items-center space-x-2 w-full md:w-auto justify-end z-30">
                <div class="relative group">
                    <input type="text" id="localSearchInput" placeholder="本棚内検索..." class="w-32 md:w-48 liquid-glass rounded-smooth px-3 py-1.5 text-gray-900 dark:text-gray-100 placeholder-gray-500 focus:w-56 pr-8 transition-all">
                    <button id="clearLocalSearch" class="hidden absolute right-2 top-1.5 text-gray-400 hover:text-accent font-bold" onclick="clearLocalSearch(); triggerHaptic();">×</button>
                </div>
                <div class="popover-container">
                    <button id="trigger-filter" onclick="togglePopover(event, 'filter', this); triggerHaptic();" class="popover-trigger liquid-glass rounded-smooth flex items-center space-x-2 px-3 py-1.5 min-w-[110px] justify-between haptic-tap"><span class="text-[10px] font-bold text-gray-500">FILTER</span><span id="label-filter" class="font-bold truncate ml-2">すべて</span><span class="text-[8px] text-gray-400 ml-1">▼</span></button>
                    <div id="popover-filter" class="absolute-popover"><div onclick="selectFilter('all'); triggerHaptic();" class="popover-item" id="opt-filter-all"><span>すべて表示</span><span class="popover-check">✓</span></div><div onclick="selectFilter('unread'); triggerHaptic();" class="popover-item" id="opt-filter-unread"><span>読みたい</span><span class="popover-check">✓</span></div><div onclick="selectFilter('reading'); triggerHaptic();" class="popover-item" id="opt-filter-reading"><span>読書途中</span><span class="popover-check">✓</span></div><div onclick="selectFilter('completed'); triggerHaptic();" class="popover-item" id="opt-filter-completed"><span>読書完了</span><span class="popover-check">✓</span></div></div>
                </div>
                <div class="popover-container">
                    <button id="trigger-sort" onclick="togglePopover(event, 'sort', this); triggerHaptic();" class="popover-trigger liquid-glass rounded-smooth flex items-center space-x-2 px-3 py-1.5 min-w-[110px] justify-between haptic-tap"><span class="text-[10px] font-bold text-gray-500">SORT</span><span id="label-sort" class="font-bold truncate ml-2">新しい順</span><span class="text-[8px] text-gray-400 ml-1">▼</span></button>
                    <div id="popover-sort" class="absolute-popover"><div onclick="selectSort('added_desc'); triggerHaptic();" class="popover-item" id="opt-sort-added_desc"><span>登録が新しい順</span><span class="popover-check">✓</span></div><div onclick="selectSort('rank_desc'); triggerHaptic();" class="popover-item" id="opt-sort-rank_desc"><span>評価ランク順</span><span class="popover-check">✓</span></div><div onclick="selectSort('title_asc'); triggerHaptic();" class="popover-item" id="opt-sort-title_asc"><span>タイトル順</span><span class="popover-check">✓</span></div></div>
                </div>
            </div>
        </div>
    </header>

    <main class="flex-grow w-full px-4 md:px-6 py-6 overflow-x-hidden relative min-h-[500px]">
        <div id="view-content-grid" class="view-content w-full"><div id="bookshelf-grid" class="book-grid"></div></div>
        
        <div id="view-content-tag" class="view-content w-full hidden">
            <div id="bookshelf-tag" class="max-w-7xl mx-auto pb-4"></div>
        </div>

        <div id="view-content-kanban" class="view-content w-full h-full hidden">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 h-full overflow-x-auto pb-4">
                <div class="flex flex-col h-full"><div class="flex items-center justify-between mb-4 pb-2 border-b border-gray-300 dark:border-gray-700"><h3 class="font-extrabold text-xs tracking-widest text-gray-500 uppercase">読みたい</h3><span id="count-unread" class="bg-gray-200 dark:bg-gray-800 text-xs px-2 py-0.5 font-mono rounded-md">0</span></div><div id="col-unread" class="kanban-col bg-gray-100 dark:bg-darkCard p-3 space-y-3 flex-1 transition-colors border border-dashed border-gray-300 dark:border-gray-700 rounded-smooth"></div></div>
                <div class="flex flex-col h-full"><div class="flex items-center justify-between mb-4 pb-2 border-b border-accent"><h3 class="font-extrabold text-xs tracking-widest text-accent uppercase">読書途中</h3><span id="count-reading" class="bg-blue-50 dark:bg-blue-900/30 text-accent text-xs px-2 py-0.5 font-mono rounded-md">0</span></div><div id="col-reading" class="kanban-col bg-gray-100 dark:bg-darkCard p-3 space-y-3 flex-1 transition-colors border border-dashed border-gray-300 dark:border-gray-700 rounded-smooth"></div></div>
                <div class="flex flex-col h-full"><div class="flex items-center justify-between mb-4 pb-2 border-b border-green-500"><h3 class="font-extrabold text-xs tracking-widest text-green-600 dark:text-green-500 uppercase">読書完了</h3><span id="count-completed" class="bg-green-50 dark:bg-green-900/30 text-green-600 dark:text-green-500 text-xs px-2 py-0.5 font-mono rounded-md">0</span></div><div id="col-completed" class="kanban-col bg-gray-100 dark:bg-darkCard p-3 space-y-3 flex-1 transition-colors border border-dashed border-gray-300 dark:border-gray-700 rounded-smooth"></div></div>
            </div>
        </div>
        <div id="view-content-timeline" class="view-content w-full hidden"><div class="max-w-3xl mx-auto timeline-container" id="bookshelf-timeline"><div class="timeline-line"></div></div></div>
        <div id="emptyMessage" class="hidden flex flex-col items-center justify-center py-40 text-gray-300 dark:text-gray-600 absolute inset-0 pointer-events-none"><div class="w-16 h-16 border-2 border-current flex items-center justify-center mb-4 rounded-full"><svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg></div><p class="text-xs font-bold tracking-widest uppercase">本が登録されていません</p></div>
    </main>
    
    <footer class="w-full text-center py-8 text-[10px] text-gray-400 font-sans tracking-widest">
        &copy; KOYO ANDO
    </footer>

    <div id="modal" class="fixed inset-0 z-50 hidden transition-opacity duration-300">
        <div class="absolute inset-0 bg-white/60 dark:bg-black/60 backdrop-blur-xl" onclick="closeModal(); triggerHaptic();"></div>
        <div class="absolute inset-0 flex items-center justify-center pointer-events-none p-4 md:p-10">
            <div id="modalCard" class="w-full h-full max-w-6xl border border-gray-200 dark:border-gray-800 bg-white dark:bg-darkCard shadow-apple-float flex flex-col md:flex-row overflow-hidden rounded-smooth pointer-events-auto">
                <button onclick="closeModal(); triggerHaptic();" class="absolute top-0 right-0 p-6 text-3xl hover:text-accent z-20 haptic-tap transition-colors text-gray-400 dark:text-gray-500">&times;</button>
                <div class="md:w-1/4 lg:w-1/5 bg-gray-50 dark:bg-black/30 p-8 flex flex-col items-center border-r border-gray-100 dark:border-gray-800 overflow-y-auto shrink-0">
                    <div class="relative group w-28 md:w-36 aspect-[2/3] shadow-apple-card mb-6 bg-gray-200 dark:bg-zinc-800 rounded-lg overflow-hidden flex items-center justify-center flex-shrink-0">
                        <img id="modalImage" src="" class="w-full h-full object-cover transition-transform duration-700 hover:scale-105" onerror="this.src='https://via.placeholder.com/150x220?text=No+Image'">
                        <div id="imgEditBtn" class="absolute top-2 right-2 w-8 h-8 bg-white/90 text-black rounded-full flex items-center justify-center shadow cursor-pointer z-30 hover:scale-110 transition" onclick="toggleImageMenu(event, this); triggerHaptic();"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path></svg></div>
                    </div>
                    <h2 id="modalTitle" class="text-lg font-bold text-center mb-2 leading-tight dark:text-white tracking-tight"></h2><p id="modalAuthor" class="text-xs text-gray-500 font-mono mb-8 text-center"></p>
                    <div class="w-full space-y-5 mt-auto">
                        
                        <div class="space-y-1 relative" id="rank-ui-container">
                            <label class="block text-[10px] text-gray-400 font-bold uppercase tracking-widest">Rank</label>
                            <button id="rank-trigger" onclick="toggleRankMenu(event); triggerHaptic();" class="rank-trigger haptic-tap"><span id="current-rank-label">未評価</span></button>
                            <div id="rank-menu" class="rank-menu"><div onclick="setRank(''); triggerHaptic();" class="rank-option"><span>未評価</span></div><div onclick="setRank('S'); triggerHaptic();" class="rank-option"><span class="text-S font-bold">S</span> - Masterpiece</div><div onclick="setRank('A'); triggerHaptic();" class="rank-option"><span class="text-A font-bold">A</span> - Great</div><div onclick="setRank('B'); triggerHaptic();" class="rank-option"><span class="text-B font-bold">B</span> - Good</div><div onclick="setRank('C'); triggerHaptic();" class="rank-option"><span class="text-C font-bold">C</span> - Average</div></div>
                        </div>
                        <div class="space-y-1"><label class="block text-[10px] text-gray-400 font-bold uppercase tracking-widest">Status</label><div class="status-segment"><div onclick="setModalStatus('unread'); triggerHaptic();" id="btn-unread" class="status-tab" data-val="unread">読みたい</div><div onclick="setModalStatus('reading'); triggerHaptic();" id="btn-reading" class="status-tab" data-val="reading">読書途中</div><div onclick="setModalStatus('completed'); triggerHaptic();" id="btn-completed" class="status-tab" data-val="completed">読書完了</div></div></div>
                        
                        <div class="space-y-1 pt-2 border-t border-gray-200 dark:border-gray-800">
                            <label class="block text-[10px] text-gray-400 font-bold uppercase tracking-widest">Tags</label>
                            <div class="tag-input-container" onclick="document.getElementById('tag-input').focus()">
                                <div id="tag-list" class="contents"></div>
                                <input type="text" id="tag-input" class="tag-input" placeholder="+ Add tag..." onkeypress="if(event.key==='Enter') { addTag(); triggerHaptic(); }">
                            </div>
                        </div>

                        <div class="space-y-1 pt-2 border-t border-gray-200 dark:border-gray-800"><label class="block text-[10px] text-gray-400 font-bold uppercase tracking-widest">Progress (Page)</label><div class="flex items-center space-x-2"><input type="number" id="current-page" placeholder="今" class="w-1/2 bg-[var(--bg-modal-input)] rounded-smooth px-3 py-2 text-xs font-bold text-center outline-none focus:border-accent border border-transparent dark:text-white" onchange="updateModalData()"><span class="text-gray-400">/</span><input type="number" id="total-page" placeholder="総" class="w-1/2 bg-[var(--bg-modal-input)] rounded-smooth px-3 py-2 text-xs font-bold text-center outline-none focus:border-accent border border-transparent dark:text-white" onchange="updateModalData()"></div></div>
                        <button id="modalDeleteBtn" onclick="deleteBook(); triggerHaptic();" class="block w-full text-center py-4 text-xs font-bold text-red-500 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-smooth transition haptic-tap">削除する</button>
                    </div>
                </div>
                <div class="flex-1 p-8 overflow-y-auto bg-white dark:bg-darkCard">
                    <div class="max-w-3xl mx-auto space-y-12 pb-20">
                        
                        <div class="group relative">
                            <label class="flex items-center text-xs font-extrabold text-accent mb-3 uppercase tracking-wider"><span class="w-2 h-2 bg-accent mr-2 rounded-full"></span>重要コンセプト・気づき</label>
                            
                            <div class="rich-editor-wrapper">
                                <div class="rich-toolbar" id="toolbar-concepts">
                                    <div class="toolbar-inner">
                                        <div class="integrated-palette">
                                            <div class="color-gem gem-yellow" onmousedown="preventFocusLoss(event); applyHighlight('yellow', 'toolbar-concepts'); triggerHaptic();"></div>
                                            <div class="color-gem gem-green" onmousedown="preventFocusLoss(event); applyHighlight('green', 'toolbar-concepts'); triggerHaptic();"></div>
                                            <div class="color-gem gem-pink" onmousedown="preventFocusLoss(event); applyHighlight('pink', 'toolbar-concepts'); triggerHaptic();"></div>
                                            <div class="color-gem gem-blue" onmousedown="preventFocusLoss(event); applyHighlight('blue', 'toolbar-concepts'); triggerHaptic();"></div>
                                            <div class="color-gem gem-purple" onmousedown="preventFocusLoss(event); applyHighlight('purple', 'toolbar-concepts'); triggerHaptic();"></div>
                                        </div>
                                        
                                        <div class="rich-btn" id="btn-bold-concepts" onmousedown="preventFocusLoss(event); formatText('bold', null, 'btn-bold-concepts'); triggerHaptic();" title="太字"><b class="font-serif">B</b></div>
                                        <div class="rich-btn" id="btn-underline-concepts" onmousedown="preventFocusLoss(event); formatText('underline', null, 'btn-underline-concepts'); triggerHaptic();" title="下線"><u class="font-serif">U</u></div>
                                        
                                        <div class="toolbar-divider"></div>
                                        
                                        <div class="rich-btn marker-trigger-btn" onmousedown="preventFocusLoss(event); togglePrecisionPalette('toolbar-concepts', 'editor-concepts'); triggerHaptic();" title="マーカー">
                                            <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z" /></svg>
                                        </div>
                                    </div>
                                    <div id="guide-concepts" class="selection-guide">テキストを選択してください</div>
                                </div>
                                
                                <div id="editor-concepts" class="rich-content" contenteditable="true" oninput="syncRichText('concepts')" onmouseup="checkFormatState('concepts')" onkeyup="checkFormatState('concepts')"></div>
                                <textarea id="memoConcepts" class="hidden"></textarea>
                                <div class="zen-trigger haptic-tap" onclick="openZenMode('memoConcepts'); triggerHaptic();">⛶</div>
                            </div>
                        </div>

                        <div class="group relative">
                            <label class="flex items-center text-xs font-extrabold text-gray-500 mb-3 uppercase tracking-wider"><span class="w-2 h-2 bg-gray-400 mr-2 rounded-full"></span>内容要約</label>
                            <div class="rich-editor-wrapper">
                                <div class="rich-toolbar" id="toolbar-summary">
                                    <div class="toolbar-inner">
                                        <div class="integrated-palette">
                                            <div class="color-gem gem-yellow" onmousedown="preventFocusLoss(event); applyHighlight('yellow', 'toolbar-summary'); triggerHaptic();"></div>
                                            <div class="color-gem gem-green" onmousedown="preventFocusLoss(event); applyHighlight('green', 'toolbar-summary'); triggerHaptic();"></div>
                                            <div class="color-gem gem-pink" onmousedown="preventFocusLoss(event); applyHighlight('pink', 'toolbar-summary'); triggerHaptic();"></div>
                                            <div class="color-gem gem-blue" onmousedown="preventFocusLoss(event); applyHighlight('blue', 'toolbar-summary'); triggerHaptic();"></div>
                                            <div class="color-gem gem-purple" onmousedown="preventFocusLoss(event); applyHighlight('purple', 'toolbar-summary'); triggerHaptic();"></div>
                                        </div>
                                        
                                        <div class="rich-btn" id="btn-bold-summary" onmousedown="preventFocusLoss(event); formatText('bold', null, 'btn-bold-summary'); triggerHaptic();" title="太字"><b class="font-serif">B</b></div>
                                        <div class="rich-btn" id="btn-underline-summary" onmousedown="preventFocusLoss(event); formatText('underline', null, 'btn-underline-summary'); triggerHaptic();" title="下線"><u class="font-serif">U</u></div>
                                        <div class="toolbar-divider"></div>
                                        
                                        <div class="rich-btn marker-trigger-btn" onmousedown="preventFocusLoss(event); togglePrecisionPalette('toolbar-summary', 'editor-summary'); triggerHaptic();" title="マーカー">
                                            <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z" /></svg>
                                        </div>
                                    </div>
                                    <div id="guide-summary" class="selection-guide">テキストを選択してください</div>
                                </div>
                                
                                <div id="editor-summary" class="rich-content" contenteditable="true" oninput="syncRichText('summary')" onmouseup="checkFormatState('summary')" onkeyup="checkFormatState('summary')"></div>
                                <textarea id="memoSummary" class="hidden"></textarea>
                                <div class="zen-trigger haptic-tap" onclick="openZenMode('memoSummary'); triggerHaptic();">⛶</div>
                            </div>
                        </div>

                        <div class="group relative">
                            <label class="flex items-center text-xs font-extrabold text-gray-500 mb-3 uppercase tracking-wider"><span class="w-2 h-2 bg-gray-400 mr-2 rounded-full"></span>個人的な感想</label>
                            <div class="rich-editor-wrapper">
                                <div class="rich-toolbar" id="toolbar-review">
                                    <div class="toolbar-inner">
                                        <div class="integrated-palette">
                                            <div class="color-gem gem-yellow" onmousedown="preventFocusLoss(event); applyHighlight('yellow', 'toolbar-review'); triggerHaptic();"></div>
                                            <div class="color-gem gem-green" onmousedown="preventFocusLoss(event); applyHighlight('green', 'toolbar-review'); triggerHaptic();"></div>
                                            <div class="color-gem gem-pink" onmousedown="preventFocusLoss(event); applyHighlight('pink', 'toolbar-review'); triggerHaptic();"></div>
                                            <div class="color-gem gem-blue" onmousedown="preventFocusLoss(event); applyHighlight('blue', 'toolbar-review'); triggerHaptic();"></div>
                                            <div class="color-gem gem-purple" onmousedown="preventFocusLoss(event); applyHighlight('purple', 'toolbar-review'); triggerHaptic();"></div>
                                        </div>
                                        
                                        <div class="rich-btn" id="btn-bold-review" onmousedown="preventFocusLoss(event); formatText('bold', null, 'btn-bold-review'); triggerHaptic();" title="太字"><b class="font-serif">B</b></div>
                                        <div class="rich-btn" id="btn-underline-review" onmousedown="preventFocusLoss(event); formatText('underline', null, 'btn-underline-review'); triggerHaptic();" title="下線"><u class="font-serif">U</u></div>
                                        <div class="toolbar-divider"></div>
                                        
                                        <div class="rich-btn marker-trigger-btn" onmousedown="preventFocusLoss(event); togglePrecisionPalette('toolbar-review', 'editor-review'); triggerHaptic();" title="マーカー">
                                            <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z" /></svg>
                                        </div>
                                    </div>
                                    <div id="guide-review" class="selection-guide">テキストを選択してください</div>
                                </div>

                                <div id="editor-review" class="rich-content" contenteditable="true" oninput="syncRichText('review')" onmouseup="checkFormatState('review')" onkeyup="checkFormatState('review')"></div>
                                <textarea id="memoReview" class="hidden"></textarea>
                                <div class="zen-trigger haptic-tap" onclick="openZenMode('memoReview'); triggerHaptic();">⛶</div>
                            </div>
                        </div>

                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="legalModal" class="fixed inset-0 z-[99999] hidden flex items-center justify-center bg-black/90 backdrop-blur-sm p-4">
        <div class="bg-white dark:bg-darkCard w-full max-w-lg rounded-smooth shadow-2xl overflow-hidden flex flex-col h-auto max-h-[90vh]">
            <div class="p-6 border-b border-gray-100 dark:border-gray-800 shrink-0">
                <h2 class="text-xl font-extrabold text-center tracking-widest text-accent">TERMS & PRIVACY</h2>
            </div>
            <div class="p-6 overflow-y-auto legal-modal-content flex-1">
                <p class="font-bold mb-2">【利用規約・免責事項】</p>
                <ul class="list-disc pl-5 space-y-2 mb-4 text-xs leading-relaxed">
                    <li><strong>対象ユーザー:</strong> 本サービスは日本国内居住者を対象としています。</li>
                    <li><strong>データの保存場所:</strong> データはお客様のブラウザ内（LocalStorage）にのみ保存され、サーバーへ送信されることはありません。</li>
                    <li><strong>データ保護:</strong> 保存データは簡易的な難読化処理が行われますが、共有PC等での利用時はブラウザを閉じるだけでなく、キャッシュクリア等の対策を推奨します。</li>
                    <li><strong>禁止事項:</strong> 本アプリのソースコードの無断複製、再配布、リバースエンジニアリング、および違法行為への利用を禁止します。</li>
                    <li><strong>著作権:</strong> 本アプリ自体の著作権は KOYO ANDO に帰属します。書籍データ（表紙・タイトル等）の権利は各権利者に帰属します。</li>
                    <li><strong>免責事項（データ消失）:</strong> ブラウザのキャッシュクリアや不具合によるデータ消失について、開発者は一切責任を負いません。定期的なバックアップ（JSON保存）を推奨します。</li>
                    <li><strong>免責事項（API・個人情報）:</strong> Google Books APIの停止等によりサービスが利用できなくなる可能性があります。また、入力されたメモ等に含まれる個人情報の漏洩（共有機能の誤用等を含む）について、開発者は責任を負いません。</li>
                    <li><strong>規約の変更:</strong> 本規約は予告なく変更される場合があります。</li>
                    <li><strong>準拠法:</strong> 本規約の解釈にあたっては、日本法を準拠法とします。</li>
                </ul>
                <p class="text-[10px] text-gray-500 mt-4 text-center">以下のボタンを押すことで、上記すべてに同意したものとみなされます。</p>
            </div>
            <div class="p-6 bg-gray-50 dark:bg-zinc-900 border-t border-gray-100 dark:border-gray-800 shrink-0">
                <button onclick="acceptLegal(); triggerHaptic();" class="w-full bg-accent hover:opacity-90 text-white font-bold py-3 rounded-smooth transition haptic-tap shadow-lg">同意して利用開始</button>
            </div>
        </div>
    </div>
    
    <div id="guideModal" class="fixed inset-0 z-[99999] hidden flex items-center justify-center bg-black/90 backdrop-blur-sm p-4 px-4 md:px-0">
        <div class="bg-white dark:bg-darkCard w-full max-w-3xl rounded-smooth shadow-2xl overflow-hidden flex flex-col max-h-[80vh]">
            <div class="relative p-4 md:p-6 flex-1 flex items-center justify-center bg-gray-100 dark:bg-black overflow-hidden">
                <img src="./Gemini_Generated_Image_qtqq4iqtqq4iqtqq.png" class="max-w-full max-h-full object-contain rounded-md shadow-sm" alt="BookLog Guide">
                <button onclick="closeGuide(); triggerHaptic();" class="absolute top-2 right-2 md:top-4 md:right-4 bg-black/50 hover:bg-black/80 text-white rounded-full p-1.5 md:p-2 transition backdrop-blur-md z-10 haptic-tap">
                    <svg class="w-5 h-5 md:w-6 md:h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <div class="p-4 md:p-6 bg-white dark:bg-darkCard border-t border-gray-100 dark:border-gray-800 text-center shrink-0">
                <h3 class="text-base md:text-lg font-bold mb-2 dark:text-white">ようこそ BOOKLOG へ</h3>
                <p class="text-xs text-gray-500 mb-4 leading-relaxed">PC・スマホ両対応。<br class="md:hidden">あなたの読書体験を美しく記録・管理します。</p>
                <button onclick="closeGuide(); triggerHaptic();" class="px-6 py-2.5 md:px-8 md:py-3 bg-accent text-white font-bold text-xs md:text-sm rounded-full hover:shadow-glow transition transform hover:scale-105 active:scale-95 haptic-tap">記録開始</button>
            </div>
        </div>
    </div>

    <div id="settingsMenu" class="fixed top-0 right-0 h-full w-72 bg-white dark:bg-darkCard border-l border-gray-100 dark:border-gray-800 shadow-2xl transform translate-x-full transition-transform duration-300 ease-in-out z-50 flex flex-col overflow-y-auto"><div class="p-6 border-b border-gray-100 dark:border-gray-800 flex justify-between items-center bg-gray-50 dark:bg-black"><h3 class="font-bold dark:text-white tracking-widest text-xs uppercase">Menu / 統計</h3><button onclick="toggleSettings(); triggerHaptic();" class="text-xl haptic-tap dark:text-white hover:text-gray-500">&times;</button></div><div class="p-6 space-y-8 flex-1"><div><p class="text-[10px] font-bold text-gray-400 uppercase mb-4">読書データ</p><div class="donut-chart mb-4" id="donutChart"><div class="donut-inner"><span id="stat-total" class="text-2xl font-extrabold dark:text-white">0</span></div></div><div class="space-y-3 text-xs"><div class="flex justify-between items-center"><div class="flex items-center"><span class="w-2 h-2 bg-gray-300 mr-2 rounded-full"></span>読みたい</div><span id="stat-unread" class="font-bold dark:text-white">0</span></div><div class="flex justify-between items-center"><div class="flex items-center"><span class="w-2 h-2 bg-accent mr-2 rounded-full"></span>読書途中</div><span id="stat-reading" class="font-bold dark:text-white">0</span></div><div class="flex justify-between items-center"><div class="flex items-center"><span class="w-2 h-2 bg-green-500 mr-2 rounded-full"></span>読書完了</div><span id="stat-completed" class="font-bold dark:text-white">0</span></div></div></div><div class="space-y-2 pt-4 border-t border-gray-100 dark:border-gray-800"><p class="text-[10px] font-bold text-gray-400 uppercase">データ管理</p><button onclick="exportData(); triggerHaptic();" class="w-full liquid-glass rounded-smooth p-3 text-left text-xs font-bold dark:text-white haptic-tap">バックアップ保存</button><label class="w-full liquid-glass rounded-smooth p-3 text-left text-xs font-bold cursor-pointer block dark:text-white haptic-tap">データ復元<input type="file" class="hidden" onchange="importData(this); triggerHaptic();"></label></div><div class="text-[10px] text-gray-400">Powered by Google Books API</div></div><div class="p-4 text-center text-[10px] text-gray-400 bg-gray-50 dark:bg-black">BOOKLOG</div></div>

    <script>
        // === HAPTIC FEEDBACK ===
        function triggerHaptic() {
            // Check for navigator.vibrate support (Android/some devices)
            if (navigator.vibrate) {
                navigator.vibrate(10); // Ultra short tick
            }
        }

        // === Security: Sanitization (XSS) ===
        function escapeHTML(str) {
            if(!str) return '';
            return String(str).replace(/[&<>'"]/g, tag => ({
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                "'": '&#39;',
                '"': '&quot;'
            }[tag]));
        }

        // === Security: Prototype Pollution Protection ===
        function secureJSONParse(text) {
            return JSON.parse(text, (key, value) => {
                if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
                    console.warn(`[Security] Dropped dangerous key: ${key}`);
                    return undefined; 
                }
                return value;
            });
        }

        // === Security: Input Validation ===
        function validateBookSchema(book) {
            if (typeof book !== 'object' || book === null) return false;
            const isValidId = typeof book.id === 'string' && book.id.length > 0 && book.id.length < 50; 
            const isValidTitle = typeof book.title === 'string' && book.title.length < 500; 
            const isValidStatus = ['unread', 'reading', 'completed'].includes(book.status);
            if (book.customImage && book.customImage.length > 3000000) return false; 
            if ('__proto__' in book || 'constructor' in book) return false;
            
            // Ensure tags array exists
            if (!Array.isArray(book.tags)) book.tags = [];
            
            return isValidId && isValidTitle && isValidStatus;
        }

        // V37 HIGHLIGHT & OMNI-SEARCH
        function stripTags(html) {
           let doc = new DOMParser().parseFromString(html, 'text/html');
           return doc.body.textContent || "";
        }

        function highlightText(text, query) {
            const safeText = escapeHTML(text);
            if (!query) return safeText;
            const queries = query.split(/\s+/).filter(q => q.length > 0);
            let result = safeText;
            queries.forEach(q => {
                const safeQ = escapeHTML(q);
                const regex = new RegExp(`(${safeQ})`, 'gi');
                result = result.replace(regex, '<span class="search-highlight">$1</span>');
            });
            return result;
        }

        let currentZenTarget = null; let zenDebounce = null;
        function openZenMode(targetId) { 
            currentZenTarget = targetId; 
            const originalVal = document.getElementById(targetId).value; 
            const zenText = document.getElementById('zenTextarea'); 
            zenText.value = stripTags(originalVal); 
            zenText.oninput = (e) => { 
                const val = e.target.value; 
                document.getElementById(targetId).value = val;
                const type = targetId.replace('memo', '').toLowerCase();
                document.getElementById(`editor-${type}`).innerText = val; 
                clearTimeout(zenDebounce); 
                zenDebounce = setTimeout(() => { updateModalData(); }, 1000); 
            }; 
            document.getElementById('zenOverlay').classList.add('active'); 
            zenText.focus(); 
        }
        function closeZenMode() { document.getElementById('zenOverlay').classList.remove('active'); updateModalData(); currentZenTarget = null; }
        window.addEventListener('keydown', (e) => { if (e.key === 'Escape' && document.getElementById('zenOverlay').classList.contains('active')) { closeZenMode(); } });

        async function doSearch(q){ 
            // あなたのAPIキーを設定
            const API_KEY = 'AIzaSyBm1kzNUkIq1OcnJNVhr6QSfbg4tUqbX3I';

            sBox.classList.remove('hidden');
            sBox.innerHTML='<div class="p-4 text-xs">検索中...</div>'; 
            try{ 
                // URLの末尾にAPIキーを追加してリクエストします
                const r=await fetch(`https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(q)}&maxResults=40&orderBy=relevance&key=${API_KEY}`); 
                
                if (r.status === 429) {
                    sBox.innerHTML='<div class="p-4 text-xs text-red-500">アクセスが集中しています。しばらく待ってから再検索してください。</div>';
                    return;
                }
                const d=await r.json();
                sBox.innerHTML=''; 
                if(d.items){ 
                    const validItems=d.items.filter(i=>i.volumeInfo); 
                    validItems.forEach(i=>{ 
                        const div=document.createElement('div'); 
                        div.className="flex items-center p-3 hover:bg-gray-100 dark:hover:bg-zinc-800 cursor-pointer border-b border-gray-200 dark:border-gray-700 haptic-tap transition-colors"; 
                        let rawImg = i.volumeInfo.imageLinks?.thumbnail || '';
                        if(rawImg.startsWith('http:')) rawImg = rawImg.replace('http:', 'https:');
                        const img = escapeHTML(rawImg);
                        const title=escapeHTML(i.volumeInfo.title||'No Title'); 
                        const authors=escapeHTML(i.volumeInfo.authors?.join(', ')||''); 
                        div.innerHTML=`<img src="${img}" class="w-8 h-12 object-cover mr-3 bg-gray-200 rounded-md" onerror="this.src='https://via.placeholder.com/32x48?text=No+Img'"><div class="flex-1 min-w-0"><p class="text-xs font-bold truncate dark:text-white">${title}</p><p class="text-[10px] text-gray-500 truncate">${authors}</p></div><span class="text-[10px] font-bold text-accent">追加</span>`; 
                        div.onclick=()=> { addBook(i); triggerHaptic(); };
                        sBox.appendChild(div); 
                    }); 
                } else { sBox.innerHTML='<div class="p-4 text-xs">見つかりませんでした</div>'; } 
            }catch(e){ console.error(e); sBox.innerHTML='<div class="p-4 text-xs">エラーが発生しました</div>'; } 
        }

        function moveHighlighter(targetBtn, isMobile = false) { const highlighter = document.getElementById(isMobile ? 'liquid-highlighter-mobile' : 'liquid-highlighter-pc'); highlighter.style.width = `${targetBtn.offsetWidth}px`; highlighter.style.transform = `translateX(${targetBtn.offsetLeft}px)`; targetBtn.parentElement.querySelectorAll('.liquid-tab').forEach(b => b.classList.remove('active')); targetBtn.classList.add('active'); }
        let myBooks = []; let lastUpdated = 0; let currentView = 'grid'; let currentState = { filter: 'all', sort: 'added_desc' }; let currentEditingId = null; let localQuery = "";
        
        window.addEventListener('storage', (e) => { if (e.key === 'myBooksV5') { alert('データが別のタブで更新されました。整合性を保つためページをリロードします。'); location.reload(); } });

        function checkLegal() {
            if (!localStorage.getItem('termsAccepted_v1')) {
                document.getElementById('legalModal').classList.remove('hidden');
            } else {
                const dismissed = sessionStorage.getItem('backupWarningDismissed');
                if (!dismissed) {
                    setTimeout(() => {
                        const bar = document.getElementById('backup-warning-bar');
                        bar.classList.add('visible');
                        // Auto-hide logic added
                        setTimeout(() => {
                            bar.classList.remove('visible');
                        }, 10000); // 10 seconds display
                    }, 1000);
                }
            }
        }
        function acceptLegal() { 
            localStorage.setItem('termsAccepted_v1', 'true'); 
            document.getElementById('legalModal').classList.add('hidden'); 
            // New Guide Flow
            document.getElementById('guideModal').classList.remove('hidden');
        }
        function closeGuide() {
            document.getElementById('guideModal').classList.add('hidden');
            checkLegal(); // Resume warning flow
        }
        function dismissBackupWarning() { document.getElementById('backup-warning-bar').classList.remove('visible'); sessionStorage.setItem('backupWarningDismissed', 'true'); }

        function saveSecure(key, data) { try { const jsonStr = JSON.stringify(data); const encoded = btoa(unescape(encodeURIComponent(jsonStr))); localStorage.setItem(key, encoded); } catch (e) { console.error("Save failed", e); alert("データ容量がいっぱいです。画像を減らしてください。"); } }
        function loadSecure(key) { const raw = localStorage.getItem(key); if (!raw) return null; try { const decoded = decodeURIComponent(escape(atob(raw))); return secureJSONParse(decoded); } catch (e) { try { return secureJSONParse(raw); } catch (e2) { console.error("Data corrupted"); return null; } } }

        function initApp() { 
            if(localStorage.getItem('theme') === 'dark') document.documentElement.classList.add('dark'); 
            const parsed = loadSecure('myBooksV5');
            if (parsed) { try { const validBooks = Array.isArray(parsed) ? parsed.filter(validateBookSchema) : []; myBooks = validBooks; } catch(e) { console.error("Corrupted data found", e); myBooks = []; } } 
            const defaultTab = window.innerWidth < 768 ? document.getElementById('tab-mb-grid') : document.getElementById('tab-pc-grid'); 
            if(defaultTab) setTimeout(() => moveHighlighter(defaultTab, window.innerWidth < 768), 50); 
            document.getElementById('opt-filter-all').classList.add('selected'); 
            document.getElementById('opt-sort-added_desc').classList.add('selected'); 
            applyView(); updateStats();
            checkLegal();
        }

        document.addEventListener('DOMContentLoaded', () => { 
            const filterTrigger = document.getElementById('trigger-filter'); const sortTrigger = document.getElementById('trigger-sort'); 
            filterTrigger.addEventListener('click', (e) => togglePopover(e, 'filter', filterTrigger)); 
            sortTrigger.addEventListener('click', (e) => togglePopover(e, 'sort', sortTrigger)); 
            document.getElementById('localSearchInput').addEventListener('input', (e) => { localQuery = e.target.value.toLowerCase(); document.getElementById('clearLocalSearch').classList.toggle('hidden', localQuery === ""); applyView(); }); 
            const webInput = document.getElementById('searchInput'); webInput.addEventListener('input', (e) => { document.getElementById('clearWebSearch').classList.toggle('hidden', e.target.value === ""); });
            window.addEventListener('click', (e) => { 
                if(!e.target.closest('.absolute-popover') && !e.target.closest('.popover-trigger') && !e.target.closest('.floating-popover') && !e.target.closest('.img-edit-btn') && !e.target.closest('.rich-toolbar') && !e.target.closest('.rich-btn')) closeAllPopovers(); 
                if(!e.target.closest('#rank-ui-container')) document.getElementById('rank-menu').classList.remove('open');
            }); 
            document.querySelector('.overflow-y-auto').addEventListener('scroll', () => { closeAllPopovers(); });
            initApp(); 
        });

        function showToast(msg) { const t = document.getElementById('toast'); document.getElementById('toastMsg').innerText = msg || "保存しました"; t.classList.remove('hide'); t.classList.add('show'); setTimeout(() => { t.classList.remove('show'); t.classList.add('hide'); }, 2000); }
        function togglePopover(e, type, triggerEl) { e.stopPropagation(); const popover = document.getElementById(`popover-${type}`); const isOpen = popover.classList.contains('open'); closeAllPopovers(); if (!isOpen) { popover.classList.add('open'); if(triggerEl.classList.contains('popover-trigger')) triggerEl.classList.add('active'); } }
        function toggleImageMenu(e, triggerEl) { e.stopPropagation(); const popover = document.getElementById('popover-imgEdit'); const isOpen = popover.classList.contains('open'); closeAllPopovers(); if(!isOpen) { const rect = triggerEl.getBoundingClientRect(); popover.style.top = `${rect.bottom + 8}px`; const leftPos = rect.right - 180; popover.style.left = `${leftPos}px`; popover.classList.add('open'); } }
        function closeAllPopovers() { document.querySelectorAll('.absolute-popover').forEach(el => el.classList.remove('open')); document.querySelectorAll('.floating-popover').forEach(el => el.classList.remove('open')); document.querySelectorAll('.rich-toolbar').forEach(el => { el.classList.remove('expanded'); el.classList.remove('pos-bottom'); el.classList.remove('mobile-fixed'); }); document.querySelectorAll('.popover-trigger').forEach(el => el.classList.remove('active')); }
        function selectFilter(val) { const labels = {all:'すべて', unread:'読みたい', reading:'読書途中', completed:'読書完了'}; document.getElementById('label-filter').innerText = labels[val]; document.querySelectorAll('#popover-filter .popover-item').forEach(el => el.classList.remove('selected')); document.getElementById(`opt-filter-${val}`).classList.add('selected'); currentState.filter = val; applyView(); setTimeout(closeAllPopovers, 50); }
        function selectSort(val) { const labels = {added_desc:'新しい順', rank_desc:'ランク順', title_asc:'タイトル順'}; document.getElementById('label-sort').innerText = labels[val]; document.querySelectorAll('#popover-sort .popover-item').forEach(el => el.classList.remove('selected')); document.getElementById(`opt-sort-${val}`).classList.add('selected'); currentState.sort = val; applyView(); setTimeout(closeAllPopovers, 50); }
        function clearLocalSearch() { localQuery = ""; document.getElementById('localSearchInput').value = ""; document.getElementById('clearLocalSearch').classList.add('hidden'); applyView(); }
        function clearWebSearch() { document.getElementById('searchInput').value = ""; document.getElementById('searchResults').classList.add('hidden'); document.getElementById('clearWebSearch').classList.add('hidden'); }
        window.addEventListener('resize',()=>{const m=window.innerWidth<768;const b=document.getElementById(`tab-${m?'mb':'pc'}-${currentView}`);if(b)moveHighlighter(b,m); closeAllPopovers();});
        
        // === VIEW TRANSITIONS IMPLEMENTATION (APPLE-LIKE SMOOTHNESS) ===
        function switchView(v) {
            if (v === currentView) return;

            const updateDOM = () => {
                const oldContent = document.getElementById(`view-content-${currentView}`);
                const newContent = document.getElementById(`view-content-${v}`);
                oldContent.classList.add('hidden');
                newContent.classList.remove('hidden');

                const p = document.getElementById(`tab-pc-${v}`);
                const m = document.getElementById(`tab-mb-${v}`);
                const isMobile = window.innerWidth < 768;
                if (p) moveHighlighter(p, false);
                if (m) moveHighlighter(m, true);

                currentView = v;
                applyView();
            };

            if (document.startViewTransition) {
                document.startViewTransition(() => {
                    updateDOM();
                });
            } else {
                updateDOM();
            }
        }
        
        function applyView(){ 
            document.getElementById('emptyMessage').classList.add('hidden'); 
            if(myBooks.length===0){document.getElementById('emptyMessage').classList.remove('hidden'); updateStats(); return;} 
            if(currentView==='grid') renderGrid(); else if(currentView==='kanban') renderKanban(); else if(currentView==='tag') renderTagView(); else renderTimeline(); 
            updateStats();
        }

        function getFilteredAndSortedBooks() { 
            let filtered = myBooks.filter(b => { 
                const matchesStatus = currentState.filter === 'all' || b.status === currentState.filter; 
                if(!localQuery) return matchesStatus;
                const queries = localQuery.split(/\s+/).filter(q => q.length > 0);
                const targetText = (b.title + " " + b.author + " " + (b.tags?.join(' ')||'') + " " + stripTags(b.memo_concepts||"") + " " + stripTags(b.memo_summary||"") + " " + stripTags(b.memo_review||"")).toLowerCase();
                const matchesSearch = queries.every(q => targetText.includes(q));
                return matchesStatus && matchesSearch; 
            }); 
            filtered.sort((a,b)=>{ if(currentState.sort==='added_desc')return(b.addedAt||0)-(a.addedAt||0); if(currentState.sort==='title_asc')return a.title.localeCompare(b.title); return(b.rank?4:0)-(a.rank?4:0); }); return filtered; 
        }
        
        function renderGrid(){ 
            const c=document.getElementById('bookshelf-grid');c.innerHTML=''; 
            const books = getFilteredAndSortedBooks(); 
            books.forEach(b=> { c.appendChild(createBookCard(b)); }); 
        }

        function createBookCard(b) {
            const d=document.createElement('div');
            d.className='book-card-container group cursor-pointer'; 
            d.addEventListener('click', (e) => { e.stopPropagation(); openModal(b.id, e); triggerHaptic(); });
            const r=b.rank?`<div class="rank-jewel rank-${b.rank}">${b.rank}</div>`:''; 
            const displayTitle = highlightText(b.title, localQuery);
            const displayAuthor = highlightText(b.author, localQuery);
            let progressWidth = '100%'; let statusColor = "bg-gray-300";
            if(b.status === 'completed') statusColor = "bg-green-500";
            else if(b.status === 'reading') { statusColor = "bg-accent"; if(b.page_total > 0 && b.page_current > 0) progressWidth = Math.min((b.page_current / b.page_total) * 100, 100) + '%'; else progressWidth = '10%'; } 
            else statusColor = "bg-transparent";
            let badge = "";
            if(localQuery) {
                const basicMatch = (b.title + b.author + (b.tags?.join(' ')||'')).toLowerCase().includes(localQuery.toLowerCase());
                if(!basicMatch) badge = `<div class="match-badge">📝 MEMO MATCH</div>`;
            }
            d.innerHTML=`<div class="book-card"><div class="book-img-wrapper loading"><div class="shimmer-overlay"></div>${r} ${badge}<img src="${escapeHTML(getImg(b))}" class="book-cover-image" onload="this.parentElement.classList.remove('loading')"><div class="absolute bottom-0 left-0 h-1 ${statusColor}" style="width:${progressWidth}"></div></div><div class="book-info"><h3 class="book-title">${displayTitle}</h3><p class="book-author">${displayAuthor}</p></div></div>`;
            return d;
        }

        function renderKanban(){ 
            ['unread','reading','completed'].forEach(s=>document.getElementById(`col-${s}`).innerHTML=''); 
            const books = myBooks.filter(b => !localQuery || (b.title + b.author + (b.tags?.join(' ')||'')).toLowerCase().includes(localQuery)); 
            books.forEach(b=>{ 
                const s=b.status||'unread';
                const d=document.createElement('div'); 
                d.className='bg-white dark:bg-darkCard p-3 border border-gray-100 dark:border-gray-800 shadow-apple-card cursor-grab active:cursor-grabbing flex gap-3 rounded-smooth haptic-tap'; 
                d.draggable=true; 
                d.ondragstart=e=>{e.dataTransfer.setData("text",b.id);}; 
                d.onclick=(e)=> { openModal(b.id, e); triggerHaptic(); }; 
                const displayTitle = highlightText(b.title, localQuery);
                const displayAuthor = highlightText(b.author, localQuery);
                d.innerHTML=`<img src="${escapeHTML(getImg(b))}" class="w-10 h-14 object-cover bg-gray-200 shrink-0 rounded-md"><div class="min-w-0"><h4 class="font-bold text-xs truncate dark:text-white">${displayTitle}</h4><p class="text-[10px] text-gray-500 truncate">${displayAuthor}</p></div>`;
                document.getElementById(`col-${s}`).appendChild(d); 
            }); 
        }

        /* === TAG VIEW LOGIC === */
        function renderTagView() {
            const container = document.getElementById('bookshelf-tag');
            container.innerHTML = '';
            const books = getFilteredAndSortedBooks();
            const groups = {};
            
            books.forEach(b => {
                if (!b.tags || b.tags.length === 0) {
                    if (!groups['未設定']) groups['未設定'] = [];
                    groups['未設定'].push(b);
                } else {
                    b.tags.forEach(t => {
                        if (!groups[t]) groups[t] = [];
                        groups[t].push(b);
                    });
                }
            });

            const sortedKeys = Object.keys(groups).sort();
            if(groups['未設定']) {
                sortedKeys.splice(sortedKeys.indexOf('未設定'), 1);
                sortedKeys.push('未設定');
            }

            sortedKeys.forEach(tag => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'mb-8';
                
                const header = document.createElement('div');
                header.className = 'tag-header';
                header.innerHTML = `<span class="tag-title"># ${escapeHTML(tag)}</span><span class="tag-count">${groups[tag].length}</span>`;
                
                const grid = document.createElement('div');
                grid.className = 'book-grid';
                
                groups[tag].forEach(b => {
                    grid.appendChild(createBookCard(b));
                });

                groupDiv.appendChild(header);
                groupDiv.appendChild(grid);
                container.appendChild(groupDiv);
            });
            
            if (books.length === 0) container.innerHTML = '<div class="text-center text-gray-400 py-10 text-xs">No Books Found</div>';
        }

        function drop(e,s){e.preventDefault(); const id=e.dataTransfer.getData("text");const b=myBooks.find(x=>x.id===id);if(b){b.status=s;save();applyView();}} function allowDrop(e){e.preventDefault();} function dragEnter(e){e.preventDefault();} function dragLeave(e){}
        
        function renderTimeline(){ const c=document.getElementById('bookshelf-timeline'); c.innerHTML='<div class="timeline-line"></div>'; const books = myBooks.filter(b => !localQuery || (b.title + b.author).toLowerCase().includes(localQuery)).sort((a,b)=>(b.addedAt||0)-(a.addedAt||0)); let lastYM = ""; const counts = {}; books.forEach(b => { const d = new Date(b.addedAt || Date.now()); if(isNaN(d.getTime())) return; const ym = `${d.getFullYear()}.${(d.getMonth()+1).toString().padStart(2, '0')}`; counts[ym] = (counts[ym] || 0) + 1; }); books.forEach(b=>{ const d = new Date(b.addedAt || Date.now()); const safeD = isNaN(d.getTime()) ? new Date() : d; const ym = `${safeD.getFullYear()}.${(safeD.getMonth()+1).toString().padStart(2, '0')}`; if(ym !== lastYM) { const h = document.createElement('div'); h.className = "timeline-header rounded-smooth"; h.innerHTML = `<span class="text-xl font-bold font-mono dark:text-white tracking-widest">${ym}</span><span class="ml-2 text-xs text-gray-400 font-bold">(${counts[ym]||0}冊)</span>`; c.appendChild(h); lastYM = ym; } const stText = b.status === 'reading' ? '読書中' : (b.status === 'completed' ? '読書完了' : '追加済'); const stColor = b.status === 'reading' ? 'text-accent' : (b.status === 'completed' ? 'text-green-500' : 'text-gray-400'); const div = document.createElement('div'); div.className = "relative mb-6 ml-6 flex gap-4 p-4 bg-white dark:bg-darkCard border border-gray-100 dark:border-gray-800 cursor-pointer rounded-smooth hover:border-accent transition haptic-tap shadow-apple-card"; div.onclick = (e) => { openModal(b.id, e); triggerHaptic(); }; 
        const displayTitle = highlightText(b.title, localQuery);
        div.innerHTML = `<div class="timeline-dot"></div><img src="${escapeHTML(getImg(b))}" class="w-12 h-16 object-cover bg-gray-200 shrink-0 rounded-md"><div class="flex-1 min-w-0"><div class="flex justify-between items-start"><h4 class="font-bold text-sm dark:text-white truncate">${displayTitle}</h4><span class="text-[10px] font-mono text-gray-400 shrink-0 ml-2">${safeD.getDate()}日</span></div><p class="text-xs text-gray-500 mb-1 truncate">${escapeHTML(b.author)}</p><span class="text-[10px] font-bold ${stColor}">${stText}</span></div>`; c.appendChild(div); }); }
        
        function updateStats(){
            const total = myBooks.length;
            const s = {unread:0, reading:0, completed:0};
            myBooks.forEach(b=> { if(s[b.status]!==undefined) s[b.status]++; else s.unread++; });
            document.getElementById('stat-total').innerText = total;
            document.getElementById('stat-unread').innerText = s.unread;
            document.getElementById('stat-reading').innerText = s.reading;
            document.getElementById('stat-completed').innerText = s.completed;
            if(total > 0){
                const p1 = (s.unread / total) * 100; const p2 = p1 + (s.reading / total) * 100;
                const isDark = document.documentElement.classList.contains('dark');
                const c1 = isDark ? '#2c2c2e' : '#e5e5ea'; const c2 = isDark ? '#0A84FF' : '#007AFF'; const c3 = '#32d74b';
                document.getElementById('donutChart').style.background = `conic-gradient(${c1} 0% ${p1}%, ${c2} ${p1}% ${p2}%, ${c3} ${p2}% 100%)`;
            }
        }

        const sInput=document.getElementById('searchInput'),sBox=document.getElementById('searchResults');let dbc;
        sInput.addEventListener('input',e=>{clearTimeout(dbc);if(e.target.value.length<2){sBox.classList.add('hidden');return;}dbc=setTimeout(()=>doSearch(e.target.value),400);});
        function addBook(i){
            const pages = i.volumeInfo.pageCount || 0;
            myBooks.unshift({id:i.id,title:i.volumeInfo.title,author:i.volumeInfo.authors?.join(', ')||'',image:i.volumeInfo.imageLinks?.thumbnail||'',status:'unread',rank:'',tags:[],page_current:0,page_total:pages,addedAt:Date.now()});
            save();applyView();sInput.value='';sBox.classList.add('hidden');}
        const modal=document.getElementById('modal'); 
        
        // === Rich Editor Functions ===
        function preventFocusLoss(e) { e.preventDefault(); }
        function formatText(command, value = null, btnId = null) { document.execCommand(command, false, value); updateModalData(); if(btnId) toggleActiveState(btnId); }
        function toggleActiveState(btnId) { const btn = document.getElementById(btnId); btn.classList.toggle('active-tool'); }
        function checkFormatState(type) {
            const isBold = document.queryCommandState('bold'); const isUnderline = document.queryCommandState('underline');
            const btnBold = document.getElementById(`btn-bold-${type}`); const btnUnderline = document.getElementById(`btn-underline-${type}`);
            if(isBold) btnBold.classList.add('active-tool'); else btnBold.classList.remove('active-tool');
            if(isUnderline) btnUnderline.classList.add('active-tool'); else btnUnderline.classList.remove('active-tool');
        }

        // === Precision Positioning Logic ===
        function togglePrecisionPalette(toolbarId, editorId) {
            const sel = window.getSelection(); const editor = document.getElementById(editorId); const range = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;
            if (!range || sel.isCollapsed || !editor.contains(range.commonAncestorContainer)) { const type = toolbarId.replace('toolbar-', ''); showSelectionGuide(type); }
            const toolbar = document.getElementById(toolbarId);
            const isExpanded = toolbar.classList.contains('expanded');
            document.querySelectorAll('.rich-toolbar').forEach(el => { if(el.id !== toolbarId) { el.classList.remove('expanded'); el.classList.remove('pos-bottom'); el.classList.remove('mobile-fixed'); } });
            if (isExpanded) { toolbar.classList.remove('expanded'); toolbar.classList.remove('pos-bottom'); toolbar.classList.remove('mobile-fixed'); } 
            else {
                const wrapper = toolbar.closest('.rich-editor-wrapper'); const rect = wrapper.getBoundingClientRect();
                if (window.innerWidth <= 480) { toolbar.classList.add('mobile-fixed'); } 
                else { if (rect.top < 80) { toolbar.classList.add('pos-bottom'); } else { toolbar.classList.remove('pos-bottom'); } }
                toolbar.classList.add('expanded');
            }
        }

        function applyHighlight(color, toolbarId) {
            const selection = window.getSelection(); 
            if (!selection.rangeCount) return;

            const range = selection.getRangeAt(0); 
            const span = document.createElement("span"); 
            span.className = `marker-${color}`;

            try { 
                const content = range.extractContents(); 
                span.appendChild(content); 
                range.insertNode(span); 
            } catch(e) { 
                document.execCommand('insertHTML', false, span.outerHTML); 
            }

            const toolbar = document.getElementById(toolbarId); 
            toolbar.classList.remove('expanded'); 
            toolbar.classList.remove('pos-bottom'); 
            toolbar.classList.remove('mobile-fixed');

            const type = toolbarId.replace('toolbar-', '');
            syncRichText(type);
            
            selection.removeAllRanges();
        }

        function showSelectionGuide(type) { const guide = document.getElementById(`guide-${type}`); if(guide) { guide.classList.add('show'); setTimeout(() => { guide.classList.remove('show'); }, 1500); } }
        function syncRichText(type) { const content = document.getElementById(`editor-${type}`).innerHTML; document.getElementById(`memo${type.charAt(0).toUpperCase() + type.slice(1)}`).value = content; updateModalData(); }

        function renderTags() {
            const b = myBooks.find(x => x.id === currentEditingId);
            if (!b) return;
            const container = document.getElementById('tag-list');
            container.innerHTML = '';
            if(!b.tags) b.tags = [];
            b.tags.forEach(tag => {
                const chip = document.createElement('span');
                chip.className = 'tag-chip';
                chip.innerHTML = `${escapeHTML(tag)} <span class="tag-remove" onclick="removeTag('${escapeHTML(tag)}')">×</span>`;
                container.appendChild(chip);
            });
        }

        function addTag() {
            const input = document.getElementById('tag-input');
            const val = input.value.trim();
            if (!val) return;
            const b = myBooks.find(x => x.id === currentEditingId);
            if (b) {
                if (!b.tags) b.tags = [];
                if (!b.tags.includes(val)) {
                    b.tags.push(val);
                    save();
                    renderTags();
                    if(currentView === 'tag') applyView(); 
                }
                input.value = '';
            }
        }

        function removeTag(tag) {
            const b = myBooks.find(x => x.id === currentEditingId);
            if (b && b.tags) {
                b.tags = b.tags.filter(t => t !== tag);
                save();
                renderTags();
                if(currentView === 'tag') applyView();
            }
        }

        /* === MORPHING ANIMATION WITH VIEW TRANSITIONS API === */
        let morphOriginCard = null;
        let morphOriginCover = null;

        function openModal(id, event){ 
            try {
                const b = myBooks.find(x => x.id === id); 
                if(!b) return; 
                currentEditingId = id; 

                // 押された要素の記録
                if (event && event.currentTarget) {
                    morphOriginCard = event.currentTarget.classList.contains('book-card-container') ? event.currentTarget.querySelector('.book-card') : event.currentTarget;
                    morphOriginCover = event.currentTarget.querySelector('img');
                } else {
                    morphOriginCard = null; 
                    morphOriginCover = null;
                }

                const setupModalData = () => {
                    document.getElementById('modalTitle').innerText = b.title; 
                    document.getElementById('modalAuthor').innerText = b.author; 
                    const img = document.getElementById('modalImage'); 
                    img.src = getImg(b); 
                    img.onerror = function(){ this.src='https://via.placeholder.com/150x220?text=No+Image'; }; 
                    
                    document.getElementById('editor-concepts').innerHTML = b.memo_concepts || ""; document.getElementById('memoConcepts').value = b.memo_concepts || "";
                    document.getElementById('editor-summary').innerHTML = b.memo_summary || ""; document.getElementById('memoSummary').value = b.memo_summary || "";
                    document.getElementById('editor-review').innerHTML = b.memo_review || ""; document.getElementById('memoReview').value = b.memo_review || "";
                    document.getElementById('current-page').value = b.page_current || ""; document.getElementById('total-page').value = b.page_total || "";
                    
                    updateStatusBtns(b.status || 'unread'); 
                    updateRankUI(b.rank || "");
                    renderTags(); 

                    ['concepts', 'summary', 'review'].forEach(type => { document.getElementById(`editor-${type}`).contentEditable = true; });
                    
                    modal.classList.remove('hidden'); 
                    modal.classList.add('open'); 
                };

                // View Transitions APIが使える場合のMorphing処理
                if (document.startViewTransition && morphOriginCard && morphOriginCover) {
                    modal.classList.add('morphing'); // 既存のzoomInアニメーションを無効化
                    
                    morphOriginCard.style.viewTransitionName = 'morph-modal-card';
                    morphOriginCover.style.viewTransitionName = 'morph-modal-cover';

                    const modalCard = document.getElementById('modalCard');
                    const modalImageContainer = document.getElementById('modalImage').closest('.group');

                    modalCard.style.viewTransitionName = 'morph-modal-card';
                    modalImageContainer.style.viewTransitionName = 'morph-modal-cover';

                    const transition = document.startViewTransition(() => {
                        setupModalData();
                    });

                    const cleanup = () => {
                        if(morphOriginCard && morphOriginCard.isConnected) morphOriginCard.style.viewTransitionName = '';
                        if(morphOriginCover && morphOriginCover.isConnected) morphOriginCover.style.viewTransitionName = '';
                        modalCard.style.viewTransitionName = '';
                        if(modalImageContainer) modalImageContainer.style.viewTransitionName = '';
                    };

                    transition.finished.then(cleanup).catch(cleanup);
                } else {
                    // 非対応ブラウザ・フォールバック
                    modal.classList.remove('morphing');
                    if(event && event.clientX) { 
                        const card = document.getElementById('modalCard'); 
                        const originX = (event.clientX / window.innerWidth) * 100; 
                        const originY = (event.clientY / window.innerHeight) * 100; 
                        card.style.transformOrigin = `${originX}% ${originY}%`; 
                    }
                    setupModalData();
                }
            } catch(e) { console.log(e); showToast("エラー: 本を開けませんでした"); }
        }

        function closeModal(){
            const executeClose = () => {
                modal.classList.add('hidden'); 
                modal.classList.remove('open'); 
                currentEditingId = null;
            };

            if (document.startViewTransition && morphOriginCard && morphOriginCover && morphOriginCard.isConnected) {
                const modalCard = document.getElementById('modalCard');
                const modalImageContainer = document.getElementById('modalImage').closest('.group');

                morphOriginCard.style.viewTransitionName = 'morph-modal-card';
                morphOriginCover.style.viewTransitionName = 'morph-modal-cover';
                modalCard.style.viewTransitionName = 'morph-modal-card';
                if(modalImageContainer) modalImageContainer.style.viewTransitionName = 'morph-modal-cover';

                const transition = document.startViewTransition(() => {
                    executeClose();
                });

                const cleanup = () => {
                    if(morphOriginCard && morphOriginCard.isConnected) morphOriginCard.style.viewTransitionName = '';
                    if(morphOriginCover && morphOriginCover.isConnected) morphOriginCover.style.viewTransitionName = '';
                    modalCard.style.viewTransitionName = '';
                    if(modalImageContainer) modalImageContainer.style.viewTransitionName = '';
                    morphOriginCard = null;
                    morphOriginCover = null;
                };

                transition.finished.then(cleanup).catch(cleanup);
            } else {
                executeClose();
                morphOriginCard = null;
                morphOriginCover = null;
            }
        }
        
        function updateStatusBtns(s){ document.querySelectorAll('.status-tab').forEach(el=>{ if(el.dataset.val === s) el.classList.add('active'); else el.classList.remove('active'); }); }
        function setModalStatus(s){ const b=myBooks.find(x=>x.id===currentEditingId); if(b){b.status=s;updateStatusBtns(s);save();applyView();} }
        function toggleRankMenu(e){ e.stopPropagation(); document.getElementById('rank-menu').classList.toggle('open'); }
        function setRank(val){ const b=myBooks.find(x=>x.id===currentEditingId); if(b){ b.rank=val; updateRankUI(val); save(); applyView(); } document.getElementById('rank-menu').classList.remove('open'); }
        function updateRankUI(val){ const label = document.getElementById('current-rank-label'); const trigger = document.getElementById('rank-trigger'); trigger.className = 'rank-trigger'; if(!val) { label.innerText = '未評価'; } else { label.innerText = val + (val==='S'?' - Masterpiece':(val==='A'?' - Great':(val==='B'?' - Good':' - Average'))); if(val==='S') trigger.classList.add('text-S'); if(val==='A') trigger.classList.add('text-A'); if(val==='B') trigger.classList.add('text-B'); if(val==='C') trigger.classList.add('text-C'); } }
        
        function updateModalData(){
            const b=myBooks.find(x=>x.id===currentEditingId);
            if(b){
                b.memo_concepts=document.getElementById('memoConcepts').value; 
                b.memo_summary=document.getElementById('memoSummary').value;
                b.memo_review=document.getElementById('memoReview').value;
                b.page_current = parseInt(document.getElementById('current-page').value) || 0;
                b.page_total = parseInt(document.getElementById('total-page').value) || 0;
                save();
                if(currentView === 'grid' || currentView === 'kanban' || currentView === 'tag') applyView();
            }
        }
        
        function deleteBook(){if(confirm('削除しますか？')){myBooks=myBooks.filter(x=>x.id!==currentEditingId);save();applyView();closeModal();}}
        function getImg(book){ if(book.customImage) return book.customImage; return book.image ? book.image.replace('http://','https://').replace('&edge=curl','').replace('zoom=1','zoom=2') : 'https://via.placeholder.com/150'; }
        
        function promptImageURL() { const url = prompt("画像のURLを入力してください:"); if(url) { if(!url.startsWith('http://') && !url.startsWith('https://') && !url.startsWith('data:image')) { alert("セキュリティのため、http/httpsで始まるURLのみ許可されています。"); return; } const b = myBooks.find(x=>x.id===currentEditingId); if(b) { b.customImage = url; save(); openModal(currentEditingId); applyView(); } } closeAllPopovers(); }
        function handleImageUpload(input) { if (input.files && input.files[0]) { const file = input.files[0]; if(file.size > 2097152) { alert("画像サイズが大きすぎます (最大2MB)"); return; } const reader = new FileReader(); reader.onload = function(e) { try { const b = myBooks.find(x=>x.id===currentEditingId); if(b) { b.customImage = e.target.result; save(); openModal(currentEditingId); applyView(); } } catch(err) { alert("画像の容量が大きすぎて保存できませんでした。"); } }; reader.readAsDataURL(file); } closeAllPopovers(); }
        function resetImage() { if(confirm("カスタム画像を削除して元の画像に戻しますか？")) { const b = myBooks.find(x=>x.id===currentEditingId); if(b) { delete b.customImage; save(); openModal(currentEditingId); applyView(); } } closeAllPopovers(); }
        
        function save(){ lastUpdated = Date.now(); saveSecure('myBooksV5', myBooks); localStorage.setItem('myBooksLastUpdated', lastUpdated.toString()); showToast(); }
        
        function toggleTheme(){const d=document.documentElement.classList.toggle('dark');localStorage.setItem('theme',d?'dark':'light'); updateStats();}
        function toggleSettings(){document.getElementById('settingsMenu').classList.toggle('translate-x-full');}
        function exportData(){const a=document.createElement('a');a.href=URL.createObjectURL(new Blob([JSON.stringify({version:"v50",timestamp:lastUpdated,data:myBooks})],{type:"application/json"}));a.download=`booklog_ultraglass_backup_${new Date().toISOString().slice(0,10)}.json`;a.click();}
        
        function importData(i){
            const r=new FileReader();
            r.onload=e=>{
                try{
                    if (e.target.result.length > 10000000) { throw new Error("File too large"); }
                    const j=secureJSONParse(e.target.result);
                    let n=[];let t=0;
                    if(Array.isArray(j)){ n=j; }else if(j.data){ n=j.data; t=j.timestamp||0; }
                    const validBooks = n.filter(validateBookSchema);
                    if(validBooks.length === 0 && n.length > 0) throw new Error("No valid book data found.");
                    if(validBooks.length < n.length) alert("警告: 一部の不正または巨大なデータはスキップされました。");
                    if(t<lastUpdated&&lastUpdated>0){if(!confirm("注意: 現在のデータより古いバックアップです。上書きしますか？"))return;}
                    myBooks=validBooks; save();applyView();alert('復元完了');toggleSettings();
                }catch(e){ console.error(e); alert("ファイル形式エラー、またはデータが大きすぎます。"); }
            };
            r.readAsText(i.files[0]);
        }
// === 10000% Magic Marker Logic ===
(function initMagicMarker() {
    // マジックポップオーバーをDOMに注入
    const magicPopover = document.createElement('div');
    magicPopover.className = 'magic-selection-popover';
    magicPopover.innerHTML = `
        <div class="magic-gem gem-yellow" onmousedown="preventFocusLoss(event); window.applyMagicHighlight('yellow'); triggerHaptic();"></div>
        <div class="magic-gem gem-green" onmousedown="preventFocusLoss(event); window.applyMagicHighlight('green'); triggerHaptic();"></div>
        <div class="magic-gem gem-pink" onmousedown="preventFocusLoss(event); window.applyMagicHighlight('pink'); triggerHaptic();"></div>
        <div class="magic-gem gem-blue" onmousedown="preventFocusLoss(event); window.applyMagicHighlight('blue'); triggerHaptic();"></div>
        <div class="magic-gem gem-purple" onmousedown="preventFocusLoss(event); window.applyMagicHighlight('purple'); triggerHaptic();"></div>
    `;
    document.body.appendChild(magicPopover);

    let activeMagicEditor = null;

    // テキスト選択時のイベント監視（マウスとタッチ両対応）
    document.addEventListener('mouseup', handleSelection);
    document.addEventListener('touchend', handleSelection);
    document.addEventListener('keyup', (e) => {
        if (e.key === 'Shift' || e.key.includes('Arrow')) handleSelection();
    });

    // スクロール時や画面外クリックでポップオーバーを隠す
    window.addEventListener('scroll', hideMagicPopover, true);
    document.addEventListener('mousedown', (e) => {
        if (!e.target.closest('.magic-selection-popover')) hideMagicPopover();
    });

    function handleSelection() {
        // 少し遅延させることで、ブラウザの選択状態更新を確実に捉える
        setTimeout(() => {
            const sel = window.getSelection();
            if (!sel || sel.isCollapsed || sel.toString().trim() === '') {
                hideMagicPopover();
                return;
            }

            const range = sel.getRangeAt(0);
            const container = range.commonAncestorContainer;
            const editor = container.nodeType === 3 
                ? container.parentElement.closest('.rich-content') 
                : container.closest('.rich-content');

            // リッチエディター内での選択でなければ無視
            if (!editor) {
                hideMagicPopover();
                return;
            }

            activeMagicEditor = editor.id.replace('editor-', '');

            // 選択範囲の座標を取得して、ポップオーバーをセンタリングして配置
            const rect = range.getBoundingClientRect();
            
            // ポップオーバーの幅を計算（レンダリング前なので推測値 約190px）
            const popoverWidth = magicPopover.offsetWidth || 190;
            const popoverHeight = magicPopover.offsetHeight || 50;

            let leftPos = rect.left + (rect.width / 2) - (popoverWidth / 2);
            let topPos = rect.top + window.scrollY - popoverHeight - 12;

            // 画面端にはみ出さないように調整
            if (leftPos < 10) leftPos = 10;
            if (leftPos + popoverWidth > window.innerWidth - 10) leftPos = window.innerWidth - popoverWidth - 10;
            if (topPos < window.scrollY) topPos = rect.bottom + window.scrollY + 12; // 上に余裕がなければ下に表示

            magicPopover.style.left = `${leftPos}px`;
            magicPopover.style.top = `${topPos}px`;
            magicPopover.classList.add('show');
        }, 10);
    }

    function hideMagicPopover() {
        magicPopover.classList.remove('show');
        activeMagicEditor = null;
    }

    // グローバルにハイライト適用関数を公開（既存のapplyHighlightは残したまま）
    window.applyMagicHighlight = function(color) {
        if (!activeMagicEditor) return;
        
        const sel = window.getSelection();
        if (!sel.rangeCount) return;

        const range = sel.getRangeAt(0);
        const span = document.createElement("span");
        span.className = `marker-${color}`;

        try {
            const content = range.extractContents();
            span.appendChild(content);
            range.insertNode(span);
        } catch(e) {
            document.execCommand('insertHTML', false, span.outerHTML);
        }

        // 既存の保存システムをトリガー
        syncRichText(activeMagicEditor);
        sel.removeAllRanges();
        hideMagicPopover();
    };
})();
// === 10000% Perfected Fluid Rank Segmented Control ===
(function initPerfectRank() {
    const container = document.getElementById('rank-ui-container');
    if (!container) return;

    // 前回のトラックが残っていればクリーンアップ（再実行時の安全性確保）
    const existingTrack = document.querySelector('.magic-rank-track');
    if (existingTrack) existingTrack.remove();

    // ゆとりのある新UIを生成
    const track = document.createElement('div');
    track.className = 'magic-rank-track';
    track.innerHTML = `
        <div class="magic-rank-indicator" id="magic-rank-indicator"></div>
        <div class="magic-rank-item" data-rank="" onclick="selectMagicRank(''); triggerHaptic();">未評価</div>
        <div class="magic-rank-item text-C" data-rank="C" onclick="selectMagicRank('C'); triggerHaptic();">C</div>
        <div class="magic-rank-item text-B" data-rank="B" onclick="selectMagicRank('B'); triggerHaptic();">B</div>
        <div class="magic-rank-item text-A" data-rank="A" onclick="selectMagicRank('A'); triggerHaptic();">A</div>
        <div class="magic-rank-item text-S" data-rank="S" onclick="selectMagicRank('S'); triggerHaptic();">S</div>
    `;
    container.appendChild(track);

    // 既存の保存システムへ繋ぐブリッジ関数
    window.selectMagicRank = function(val) {
        if (typeof window.setRank === 'function') window.setRank(val); 
    };

    // 既存のUI更新関数を拡張し、ピクセルパーフェクトな位置計算を実装
    const originalUpdateRankUI = window.updateRankUI;
    window.updateRankUI = function(val) {
        // 既存の裏側処理はそのまま実行（データ保存を担保）
        if (typeof originalUpdateRankUI === 'function') originalUpdateRankUI(val);
        
        const items = track.querySelectorAll('.magic-rank-item');
        const indicator = document.getElementById('magic-rank-indicator');
        let targetItem = null;
        
        // クラスのリセットとアクティブ項目の特定
        items.forEach((item) => {
            const baseClass = item.dataset.rank ? `text-${item.dataset.rank}` : '';
            item.className = `magic-rank-item haptic-tap ${baseClass}`; 
            
            if (item.dataset.rank === (val || "")) {
                targetItem = item;
                item.classList.add('is-active');
            }
        });

        if (targetItem && indicator) {
            // requestAnimationFrameを使うことで、ブラウザがDOMを描画した後の「正確なサイズと位置」を取得する
            requestAnimationFrame(() => {
                const offsetLeft = targetItem.offsetLeft;
                const offsetWidth = targetItem.offsetWidth;
                
                // ピクセル単位で正確な位置と幅にインジケーターを追従させる（絶対にズレない）
                indicator.style.transform = `translateX(${offsetLeft}px)`;
                indicator.style.width = `${offsetWidth}px`;
                indicator.className = 'magic-rank-indicator glow-' + (val || 'none');

                // Sランク選択時だけの特別フレアエフェクト
                if (val === 'S') {
                    const flare = document.createElement('div');
                    flare.className = 's-rank-flare';
                    indicator.appendChild(flare);
                    setTimeout(() => flare.remove(), 600); // アニメーション終了後にDOMから削除
                }
            });
        }
    };
})();
// === 10000% Pro Sort Logic & UI Injection ===
(function initProSort() {
    // 1. ソートメニューのUIを完全リプレイス（DOMインジェクション）
    const sortPopover = document.getElementById('popover-sort');
    if (!sortPopover) return;
    
    // アイコン付きの美しいグループ化メニューを構築
    sortPopover.innerHTML = `
        <div class="sort-section-title">タイムライン</div>
        <div onclick="selectSortPro('added_desc'); triggerHaptic();" class="sort-pro-item" id="opt-sort-added_desc">
            <div class="sort-label-group"><svg viewBox="0 0 24 24"><path d="M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z"/><path d="M12 8v4l3 3"/></svg><span>登録が新しい順</span></div><span class="popover-check">✓</span>
        </div>
        <div onclick="selectSortPro('added_asc'); triggerHaptic();" class="sort-pro-item" id="opt-sort-added_asc">
            <div class="sort-label-group"><svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg><span>登録が古い順</span></div><span class="popover-check">✓</span>
        </div>
        
        <div class="sort-section-title">メタデータ</div>
        <div onclick="selectSortPro('title_asc'); triggerHaptic();" class="sort-pro-item" id="opt-sort-title_asc">
            <div class="sort-label-group"><svg viewBox="0 0 24 24"><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></svg><span>タイトル順</span></div><span class="popover-check">✓</span>
        </div>
        <div onclick="selectSortPro('author_asc'); triggerHaptic();" class="sort-pro-item" id="opt-sort-author_asc">
            <div class="sort-label-group"><svg viewBox="0 0 24 24"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg><span>著者名順</span></div><span class="popover-check">✓</span>
        </div>
        <div onclick="selectSortPro('pages_desc'); triggerHaptic();" class="sort-pro-item" id="opt-sort-pages_desc">
            <div class="sort-label-group"><svg viewBox="0 0 24 24"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg><span>ページ数が多い順</span></div><span class="popover-check">✓</span>
        </div>

        <div class="sort-section-title">ステータス・評価</div>
        <div onclick="selectSortPro('rank_desc'); triggerHaptic();" class="sort-pro-item" id="opt-sort-rank_desc">
            <div class="sort-label-group"><svg viewBox="0 0 24 24"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg><span>評価ランク順</span></div><span class="popover-check">✓</span>
        </div>
        <div onclick="selectSortPro('progress_desc'); triggerHaptic();" class="sort-pro-item" id="opt-sort-progress_desc">
            <div class="sort-label-group"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 2v10l5.5 5.5"/></svg><span>読書進捗順</span></div><span class="popover-check">✓</span>
        </div>
    `;

    // 2. 新しいUI選択時の挙動（ネイティブアプリのようなディレイ消去を追加）
    window.selectSortPro = function(val) {
        const labels = {
            added_desc: '新しい順', added_asc: '古い順',
            title_asc: 'タイトル順', author_asc: '著者名順', pages_desc: 'ページ数順',
            rank_desc: '評価ランク順', progress_desc: '読書進捗順'
        };
        document.getElementById('label-sort').innerText = labels[val] || 'ソート';
        
        document.querySelectorAll('.sort-pro-item').forEach(el => el.classList.remove('is-selected'));
        const target = document.getElementById(`opt-sort-${val}`);
        if(target) target.classList.add('is-selected');
        
        currentState.sort = val;
        applyView();

        // 押した瞬間に色がつくのを見せてからメニューを閉じる（iOSの挙動再現）
        setTimeout(() => {
            if(typeof closeAllPopovers === 'function') closeAllPopovers();
        }, 120); 
    };

    // 初回ロード時に現在のソート状態を反映
    setTimeout(() => {
        const initialSort = currentState.sort || 'added_desc';
        const target = document.getElementById(`opt-sort-${initialSort}`);
        if(target) target.classList.add('is-selected');
    }, 100);

    // 3. 検索・フィルタ・ソートを司る心臓部の関数をモンキーパッチ（安全に上書き）
    window.getFilteredAndSortedBooks = function() { 
        // 既存の完全な検索・フィルタリングロジック（そのまま継承）
        let filtered = myBooks.filter(b => { 
            const matchesStatus = currentState.filter === 'all' || b.status === currentState.filter; 
            if(!localQuery) return matchesStatus;
            const queries = localQuery.split(/\s+/).filter(q => q.length > 0);
            const targetText = (b.title + " " + b.author + " " + (b.tags?.join(' ')||'') + " " + stripTags(b.memo_concepts||"") + " " + stripTags(b.memo_summary||"") + " " + stripTags(b.memo_review||"")).toLowerCase();
            const matchesSearch = queries.every(q => targetText.includes(q));
            return matchesStatus && matchesSearch; 
        }); 

        // ランクを数値化して絶対的にソートするための辞書
        const rankVal = { 'S': 5, 'A': 4, 'B': 3, 'C': 2, '': 1 };

        // 進化した多角的なソートロジック
        filtered.sort((a,b) => { 
            switch(currentState.sort) {
                case 'added_desc': return (b.addedAt||0) - (a.addedAt||0);
                case 'added_asc': return (a.addedAt||0) - (b.addedAt||0);
                case 'rank_desc': return (rankVal[b.rank||'']||1) - (rankVal[a.rank||'']||1);
                case 'title_asc': return (a.title||'').localeCompare(b.title||'');
                case 'author_asc': return (a.author||'').localeCompare(b.author||'');
                case 'pages_desc': return (b.page_total||0) - (a.page_total||0);
                case 'progress_desc':
                    // 進捗率（現在ページ / 総ページ）を計算してソート。未設定は0%扱い。
                    const pA = (a.page_total > 0 && a.page_current > 0) ? (a.page_current / a.page_total) : 0;
                    const pB = (b.page_total > 0 && b.page_current > 0) ? (b.page_current / b.page_total) : 0;
                    // 進捗が同じ場合は新しい順にする
                    if (pB === pA) return (b.addedAt||0) - (a.addedAt||0);
                    return pB - pA;
                default: return (b.addedAt||0) - (a.addedAt||0);
            }
        }); 
        return filtered; 
    };
})();
// === 10000% Pro Filter Logic & UI Injection ===
(function initProFilter() {
    // 1. フィルターメニューのUIを完全リプレイス（DOMインジェクション）
    const filterPopover = document.getElementById('popover-filter');
    if (!filterPopover) return;
    
    filterPopover.innerHTML = `
        <div onclick="selectFilterPro('all'); triggerHaptic();" class="filter-pro-item" data-filter="all" id="opt-filter-all">
            <div class="filter-label-group"><svg viewBox="0 0 24 24"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg><span>すべて表示</span></div><span class="filter-badge" id="badge-filter-all">0</span>
        </div>
        <div onclick="selectFilterPro('unread'); triggerHaptic();" class="filter-pro-item" data-filter="unread" id="opt-filter-unread">
            <div class="filter-label-group"><svg viewBox="0 0 24 24"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path><path d="M16 2v8l-3-2-3 2V2"></path></svg><span>読みたい</span></div><span class="filter-badge" id="badge-filter-unread">0</span>
        </div>
        <div onclick="selectFilterPro('reading'); triggerHaptic();" class="filter-pro-item" data-filter="reading" id="opt-filter-reading">
            <div class="filter-label-group"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg><span>読書途中</span></div><span class="filter-badge" id="badge-filter-reading">0</span>
        </div>
        <div onclick="selectFilterPro('completed'); triggerHaptic();" class="filter-pro-item" data-filter="completed" id="opt-filter-completed">
            <div class="filter-label-group"><svg viewBox="0 0 24 24"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg><span>読書完了</span></div><span class="filter-badge" id="badge-filter-completed">0</span>
        </div>
    `;

    // 2. 新しいフィルターUI選択時の挙動
    window.selectFilterPro = function(val) {
        const labels = {all:'すべて', unread:'読みたい', reading:'読書途中', completed:'読書完了'};
        document.getElementById('label-filter').innerText = labels[val] || 'すべて';
        
        // 選択状態のUIリセット＆付与
        document.querySelectorAll('.filter-pro-item').forEach(el => el.classList.remove('is-selected'));
        const target = document.getElementById(`opt-filter-${val}`);
        if(target) target.classList.add('is-selected');
        
        // 既存のステートに保存して画面更新
        currentState.filter = val;
        applyView();

        // 押した瞬間の色変化を見せてからポップオーバーを閉じる（iOSの挙動）
        setTimeout(() => {
            if(typeof closeAllPopovers === 'function') closeAllPopovers();
        }, 120);
    };

    // 初回ロード時に現在のフィルター状態を反映
    setTimeout(() => {
        const initialFilter = currentState.filter || 'all';
        const target = document.getElementById(`opt-filter-${initialFilter}`);
        if(target) target.classList.add('is-selected');
    }, 100);

    // 3. 既存のupdateStats関数を拡張して、メニュー内のバッジ（件数）をリアルタイム更新する
    const originalUpdateStats = window.updateStats;
    window.updateStats = function() {
        // 既存の統計更新処理（サイドバーのドーナツチャートなど）をそのまま実行
        if (typeof originalUpdateStats === 'function') originalUpdateStats();
        
        // メニューのバッジ用に件数を再集計
        const s = {unread: 0, reading: 0, completed: 0, all: myBooks.length};
        myBooks.forEach(b => { 
            if (s[b.status] !== undefined) s[b.status]++; 
            else s.unread++; 
        });
        
        // バッジのDOMに数字を流し込む
        const bAll = document.getElementById('badge-filter-all');
        const bUnread = document.getElementById('badge-filter-unread');
        const bReading = document.getElementById('badge-filter-reading');
        const bCompleted = document.getElementById('badge-filter-completed');
        
        if(bAll) bAll.innerText = s.all;
        if(bUnread) bUnread.innerText = s.unread;
        if(bReading) bReading.innerText = s.reading;
        if(bCompleted) bCompleted.innerText = s.completed;
    };
    
    // ロード時に一度バッジの数字を初期化
    if(typeof window.updateStats === 'function') window.updateStats();
})();
// === 10000% Pro Settings Menu Logic & UI Injection ===
(function initProMenu() {
    const menu = document.getElementById('settingsMenu');
    if(!menu) return;
    
    // 1. フォーカス用オーバーレイの追加（メニューの背後）
    let overlay = document.getElementById('settings-overlay');
    if(!overlay) {
        overlay = document.createElement('div');
        overlay.id = 'settings-overlay';
        // オーバーレイをタップした時もメニューが美しく閉じるようにする
        overlay.onclick = () => { if(typeof toggleSettings === 'function') toggleSettings(); };
        document.body.appendChild(overlay);
    }

    // 2. メニューの中身をiOS設定アプリ風に完全再構築（既存の機能・IDはそのまま維持）
    menu.innerHTML = `
        <div class="flex justify-between items-center px-6 pt-12 pb-6">
            <h2 class="text-3xl font-extrabold tracking-tight dark:text-white">Menu</h2>
            <button onclick="toggleSettings(); triggerHaptic();" class="bg-gray-200 dark:bg-gray-800 text-gray-500 dark:text-gray-300 rounded-full w-8 h-8 flex items-center justify-center font-bold hover:bg-gray-300 transition haptic-tap">&times;</button>
        </div>
        
        <div class="px-6 pb-20 overflow-y-auto" style="height: calc(100% - 90px);">
            <p class="text-[11px] font-bold text-gray-400 uppercase tracking-widest mb-2 ml-2">アクティビティ</p>
            <div class="menu-card">
                <div class="py-8 flex justify-center border-b border-gray-50 dark:border-gray-800/50 relative overflow-hidden">
                    <div class="donut-chart" id="donutChart">
                        <div class="donut-inner"><span id="stat-total" class="text-4xl font-extrabold dark:text-white tracking-tighter">0</span></div>
                    </div>
                </div>
                <div>
                    <div class="menu-stat-row">
                        <div class="flex items-center"><span class="w-3 h-3 rounded-full bg-gray-300 dark:bg-gray-600 mr-3 shadow-sm"></span>読みたい</div>
                        <span id="stat-unread" class="font-extrabold text-lg dark:text-white">0</span>
                    </div>
                    <div class="menu-stat-row">
                        <div class="flex items-center"><span class="w-3 h-3 rounded-full bg-accent mr-3 shadow-sm"></span>読書途中</div>
                        <span id="stat-reading" class="font-extrabold text-lg dark:text-white">0</span>
                    </div>
                    <div class="menu-stat-row">
                        <div class="flex items-center"><span class="w-3 h-3 rounded-full bg-green-500 mr-3 shadow-sm"></span>読書完了</div>
                        <span id="stat-completed" class="font-extrabold text-lg dark:text-white">0</span>
                    </div>
                </div>
            </div>

            <p class="text-[11px] font-bold text-gray-400 uppercase tracking-widest mb-2 ml-2 mt-8">データ管理</p>
            <div class="menu-card">
                <button onclick="exportData(); triggerHaptic();" class="menu-action-btn haptic-tap">
                    <span class="flex items-center"><svg class="w-5 h-5 mr-3 opacity-70" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>バックアップを保存</span>
                </button>
                <label class="menu-action-btn haptic-tap block">
                    <div class="flex items-center w-full cursor-pointer">
                        <svg class="w-5 h-5 mr-3 opacity-70" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                        <span>データを復元</span>
                    </div>
                    <input type="file" class="hidden" onchange="importData(this); triggerHaptic();">
                </label>
            </div>
            
            <div class="mt-10 mb-6 text-center">
                <p class="text-[10px] text-gray-400 font-bold uppercase tracking-widest">BookLog Ultraglass</p>
                <p class="text-[9px] text-gray-400 mt-1">Powered by Google Books API</p>
            </div>
        </div>
    `;

    // 3. toggleSettings関数をモンキーパッチして、オーバーレイの表示/非表示を連動
    const originalToggle = window.toggleSettings;
    window.toggleSettings = function() {
        const m = document.getElementById('settingsMenu');
        const o = document.getElementById('settings-overlay');
        
        const isClosed = m.classList.contains('translate-x-full');
        
        if (isClosed) {
            // メニューを開く処理
            m.classList.remove('translate-x-full');
            o.classList.add('show');
            // 開いたときに最新の統計を強制反映
            if(typeof updateStats === 'function') updateStats();
        } else {
            // メニューを閉じる処理
            m.classList.add('translate-x-full');
            o.classList.remove('show');
        }
    };

    // UIを再構築したため、既存の統計流し込み関数（updateStats）を一度発火させて数字を正しく反映する
    setTimeout(() => {
        if(typeof window.updateStats === 'function') window.updateStats();
    }, 100);
})();

// === 10000% Pro Writing Logic ===
(function initProWriting() {
    // 1. Zen Modeのライブ文字数カウンター制御
    const zenOverlay = document.getElementById('zenOverlay');
    const zenTextarea = document.getElementById('zenTextarea');
    
    if (zenOverlay && zenTextarea) {
        // カウンターDOMの生成と注入
        let counter = document.getElementById('zen-char-counter');
        if (!counter) {
            counter = document.createElement('div');
            counter.id = 'zen-char-counter';
            counter.className = 'zen-char-counter';
            zenOverlay.appendChild(counter);
        }

        // 入力時に文字数をカウント（空白や改行を除外した純粋な文字数）
        zenTextarea.addEventListener('input', () => {
            const len = zenTextarea.value.replace(/\s+/g, '').length;
            counter.innerText = `${len} 文字`;
            
            // 1文字以上入力されていればフワッと表示
            if (len > 0) counter.classList.add('show');
            else counter.classList.remove('show');
        });

        // 既存のopenZenModeを拡張して、開いた瞬間に文字数を計算させる
        const originalOpenZenMode = window.openZenMode;
        window.openZenMode = function(targetId) {
            if (typeof originalOpenZenMode === 'function') originalOpenZenMode(targetId);
            
            // DOM更新を待ってから文字数を計算
            setTimeout(() => {
                const len = zenTextarea.value.replace(/\s+/g, '').length;
                counter.innerText = `${len} 文字`;
                if (len > 0) counter.classList.add('show');
                else counter.classList.remove('show');
            }, 50);
        };
    }

    // 2. ゴーストプレースホルダーの安全性確保
    // リッチエディターで文字を全消去した際、見えない<br>タグが残ってプレースホルダーが出ない問題を解決
    const editors = document.querySelectorAll('.rich-content');
    editors.forEach(editor => {
        editor.addEventListener('blur', function() {
            const html = this.innerHTML.trim();
            // 改行タグだけ残ってしまった場合は完全な空にリセットする
            if (html === '<br>' || html === '<div><br></div>' || html === '<p><br></p>') {
                this.innerHTML = '';
                
                // 裏側の保存用textareaも空に同期させる
                const type = this.id.replace('editor-', '');
                const memoId = 'memo' + type.charAt(0).toUpperCase() + type.slice(1);
                const hiddenMemo = document.getElementById(memoId);
                if (hiddenMemo) hiddenMemo.value = '';
                
                // 既存の保存関数をトリガー
                if (typeof updateModalData === 'function') updateModalData();
            }
        });
    });
})();

// === 10000% Ultra-Compact Pro Menu Logic & UI Injection ===
(function initUltraCompactMenu() {
    const menu = document.getElementById('settingsMenu');
    if(!menu) return;
    
    // メニューの中身を再構築（文字サイズと余白を極限まで圧縮＆洗練）
    menu.innerHTML = `
        <div class="flex justify-between items-center px-5 pt-10 pb-4">
            <h2 class="text-lg font-extrabold tracking-tight dark:text-white">設定 / 統計</h2>
            <button onclick="toggleSettings(); triggerHaptic();" class="bg-black/5 dark:bg-white/10 text-gray-500 dark:text-gray-300 rounded-full w-6 h-6 flex items-center justify-center font-bold hover:bg-black/10 transition haptic-tap text-xs">&times;</button>
        </div>
        
        <div class="px-5 pb-10 overflow-y-auto" style="height: calc(100% - 70px);">
            <p class="text-[9px] font-bold text-gray-400 uppercase tracking-wider mb-1.5 ml-1">アクティビティ</p>
            <div class="compact-menu-card">
                <div class="py-2 flex justify-center border-b border-black/5 dark:border-white/5 relative overflow-hidden">
                    <div class="compact-donut-wrapper">
                        <div class="donut-chart" id="donutChart">
                            <div class="donut-inner"><span id="stat-total" class="text-2xl font-extrabold dark:text-white tracking-tighter">0</span></div>
                        </div>
                    </div>
                </div>
                <div>
                    <div class="compact-stat-row">
                        <div class="flex items-center"><span class="w-2.5 h-2.5 rounded-full bg-gray-300 dark:bg-gray-600 mr-2.5 shadow-sm"></span>読みたい</div>
                        <span id="stat-unread" class="font-bold text-sm dark:text-white font-mono">0</span>
                    </div>
                    <div class="compact-stat-row">
                        <div class="flex items-center"><span class="w-2.5 h-2.5 rounded-full bg-accent mr-2.5 shadow-sm"></span>読書途中</div>
                        <span id="stat-reading" class="font-bold text-sm dark:text-white font-mono">0</span>
                    </div>
                    <div class="compact-stat-row">
                        <div class="flex items-center"><span class="w-2.5 h-2.5 rounded-full bg-green-500 mr-2.5 shadow-sm"></span>読書完了</div>
                        <span id="stat-completed" class="font-bold text-sm dark:text-white font-mono">0</span>
                    </div>
                </div>
            </div>

            <p class="text-[9px] font-bold text-gray-400 uppercase tracking-wider mb-1.5 ml-1 mt-6">データ管理</p>
            <div class="compact-menu-card">
                <button onclick="exportData(); triggerHaptic();" class="compact-action-btn haptic-tap">
                    <span class="flex items-center"><svg class="w-4 h-4 mr-2.5 opacity-80" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>バックアップを保存</span>
                </button>
                <label class="compact-action-btn haptic-tap block">
                    <div class="flex items-center w-full cursor-pointer">
                        <svg class="w-4 h-4 mr-2.5 opacity-80" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                        <span>データを復元</span>
                    </div>
                    <input type="file" class="hidden" onchange="importData(this); triggerHaptic();">
                </label>
            </div>
            
            <div class="mt-8 text-center opacity-50">
                <p class="text-[9px] text-gray-400 font-bold uppercase tracking-widest">BookLog</p>
            </div>
        </div>
    `;

    // 統計を再描画して文字数などを更新
    setTimeout(() => {
        if(typeof window.updateStats === 'function') window.updateStats();
    }, 100);
})();

// === 10000% Dynamic Island Tabs Logic ===
(function initDynamicTabs() {
    // 1. 各タブに割り当てる専用のSVGアイコン
    const icons = {
        'grid': '<svg viewBox="0 0 24 24"><rect x="3" y="3" width="7" height="7" rx="1"></rect><rect x="14" y="3" width="7" height="7" rx="1"></rect><rect x="14" y="14" width="7" height="7" rx="1"></rect><rect x="3" y="14" width="7" height="7" rx="1"></rect></svg>',
        'tag': '<svg viewBox="0 0 24 24"><line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line></svg>',
        'timeline': '<svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>'
    };

    // 2. PC版とモバイル版のタブにアイコンとラベルを注入
    ['pc', 'mb'].forEach(device => {
        ['grid', 'tag', 'timeline'].forEach(view => {
            const tab = document.getElementById(`tab-${device}-${view}`);
            if (tab) {
                const text = view.toUpperCase();
                // 内部をラップして、アニメーション可能な構造に書き換える
                tab.innerHTML = `<div class="tab-inner">${icons[view]}<span class="tab-label">${text}</span></div>`;
            }
        });
    });

    // 3. 注入後に、既存のハイライター（背景の白いカプセル）の位置とサイズを再計算させる
    // 既存の moveHighlighter 関数には一切触れず、正しく発火させるだけなので安全です
    setTimeout(() => {
        const activePc = document.querySelector('#tab-pc-' + (window.currentView || 'grid'));
        if(activePc && window.innerWidth >= 768) window.moveHighlighter(activePc, false);
        
        const activeMb = document.querySelector('#tab-mb-' + (window.currentView || 'grid'));
        if(activeMb && window.innerWidth < 768) window.moveHighlighter(activeMb, true);
    }, 150);
})();

// === 10000% Pro Living Logo Logic & UI Injection ===
(function initProLogo() {
    // ヘッダー内の既存ロゴ要素（H1）を探す
    const h1Elements = document.querySelectorAll('header h1');
    let targetH1 = null;
    
    h1Elements.forEach(el => {
        if (el.innerText.includes('BOOKLOG')) {
            targetH1 = el;
        }
    });

    if (targetH1) {
        // ロゴを包んでいる親コンテナ（クリックでGRIDに戻る要素）を取得
        const container = targetH1.parentElement;
        
        // CSSアニメーションを適用するためのクラスを追加
        container.classList.add('pro-logo-wrapper');
        
        // 中身を「生きたロゴ（展開するレイヤーアイコン＋グラデーションテキスト）」に書き換える
        // ※親コンテナの onclick="switchView('grid')" などはそのまま維持されます
        container.innerHTML = `
            <div class="pro-logo-icon">
                <div class="pro-logo-layer pro-logo-layer-1"></div>
                <div class="pro-logo-layer pro-logo-layer-2"></div>
                <div class="pro-logo-layer pro-logo-layer-3"></div>
            </div>
            <div class="pro-logo-text">BOOKLOG</div>
        `;
    }
})();

// === 10000% Pro Timeline Logic & UI Injection (FIXED) ===
(function initProTimeline() {
    // 既存のタイムライン描画関数を安全に上書き
    window.renderTimeline = function() {
        const c = document.getElementById('bookshelf-timeline');
        if (!c) return;
        
        c.innerHTML = '<div class="timeline-line"></div>';
        
        // 修正箇所： window.myBooks ではなく、直接変数を参照するように修正しました
        const books = myBooks
            .filter(b => !localQuery || (b.title + " " + b.author).toLowerCase().includes(localQuery.toLowerCase()))
            .sort((a,b) => (b.addedAt||0) - (a.addedAt||0));
        
        let lastYM = "";
        const counts = {};
        
        // 月別の件数を事前集計
        books.forEach(b => {
            const d = new Date(b.addedAt || Date.now());
            if(isNaN(d.getTime())) return;
            const ym = `${d.getFullYear()}.${(d.getMonth()+1).toString().padStart(2, '0')}`;
            counts[ym] = (counts[ym] || 0) + 1;
        });

        let delayIndex = 0; // 連続アニメーション用のインデックス

        books.forEach(b => {
            const d = new Date(b.addedAt || Date.now());
            const safeD = isNaN(d.getTime()) ? new Date() : d;
            const ym = `${safeD.getFullYear()}.${(safeD.getMonth()+1).toString().padStart(2, '0')}`;
            
            // 月が切り替わったタイミングでヘッダーを挿入
            if(ym !== lastYM) {
                const h = document.createElement('div');
                h.className = "timeline-header";
                h.innerHTML = `
                    <span class="text-2xl font-extrabold font-mono dark:text-white tracking-tighter">${ym}</span>
                    <span class="text-[10px] text-gray-500 font-bold tracking-widest uppercase ml-2">${counts[ym]||0} Books</span>
                `;
                c.appendChild(h);
                lastYM = ym;
            }
            
            // ステータスと色の判定
            const stText = b.status === 'reading' ? '読書中' : (b.status === 'completed' ? '読了' : '追加済');
            const stClass = b.status === 'reading' ? 'dot-reading' : (b.status === 'completed' ? 'dot-completed' : 'dot-unread');
            const stColor = b.status === 'reading' ? 'text-accent' : (b.status === 'completed' ? 'text-green-500' : 'text-gray-400');
            
            // ランクバッジの生成
            let rankHtml = '';
            if(b.rank) {
                rankHtml = `<div class="timeline-rank-badge rank-${b.rank}">${b.rank}</div>`;
            }

            // カード全体を包み、ホバー連動（group）とアニメーションディレイを設定
            const div = document.createElement('div');
            div.className = "relative flex items-start group";
            div.style.animationDelay = `${delayIndex * 0.05}s`; // 0.05秒ずつズラして表示
            delayIndex++;

            // 修正箇所：関数も直接呼び出し
            const displayTitle = typeof highlightText === 'function' ? highlightText(b.title, localQuery) : escapeHTML(b.title);
            const displayAuthor = typeof highlightText === 'function' ? highlightText(b.author, localQuery) : escapeHTML(b.author);
            const safeImg = escapeHTML(getImg(b));

            div.innerHTML = `
                <div class="timeline-dot ${stClass}"></div>
                <div class="timeline-card flex-1 haptic-tap" onclick="openModal('${b.id}', event); triggerHaptic();">
                    ${rankHtml}
                    <img src="${safeImg}" class="w-16 h-24 object-cover bg-gray-200 shrink-0 rounded-lg shadow-sm">
                    <div class="flex-1 min-w-0 flex flex-col justify-center">
                        <div class="flex items-center gap-2 mb-1.5">
                            <span class="text-[10px] font-mono font-bold text-gray-500 bg-gray-100 dark:bg-gray-800 px-1.5 py-0.5 rounded-md">${safeD.getDate()}日</span>
                            <span class="text-[10px] font-bold ${stColor}">${stText}</span>
                        </div>
                        <h4 class="font-extrabold text-sm md:text-base dark:text-white truncate pr-10">${displayTitle}</h4>
                        <p class="text-xs text-gray-500 mt-1 truncate">${displayAuthor}</p>
                    </div>
                </div>
            `;
            c.appendChild(div);
        });
    };

    // すでにタイムラインビューが開かれている場合は即座に再描画
    if (typeof currentView !== 'undefined' && currentView === 'timeline') {
        applyView();
    }
})();

// === 10000% Perfected Tabs Highlighter Fix ===
(function fixTabHighlighter() {
    // 全体のサイズを縮小したため、背景の白いカプセルの位置を即座に再計算して合わせる
    setTimeout(() => {
        const activePc = document.querySelector('#tab-pc-' + (window.currentView || 'grid'));
        if(activePc && window.innerWidth >= 768 && typeof window.moveHighlighter === 'function') {
            window.moveHighlighter(activePc, false);
        }
        
        const activeMb = document.querySelector('#tab-mb-' + (window.currentView || 'grid'));
        if(activeMb && window.innerWidth < 768 && typeof window.moveHighlighter === 'function') {
            window.moveHighlighter(activeMb, true);
        }
    }, 150);
})();

// === 10000% Ultra-Pro Magnetic Logo Logic ===
(function initMagneticLogo() {
    // 既存のロゴ要素を探す
    const h1Elements = document.querySelectorAll('header h1');
    let targetH1 = null;
    h1Elements.forEach(el => {
        if (el.innerText.includes('BOOKLOG')) targetH1 = el;
    });

    if (targetH1) {
        const container = targetH1.parentElement;
        
        // 前回の古いクラス名が残っていればリセットし、マグネティック用のクラスを付与
        container.classList.remove('pro-logo-wrapper');
        container.classList.add('magnetic-logo-wrapper');
        
        // DOMを美しいアイコンとテキストに完全リプレイス
        container.innerHTML = `
            <div class="magnetic-logo-aura"></div>
            <div class="magnetic-logo-content">
                <svg class="magnetic-logo-icon-svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
                    <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
                </svg>
                <div class="magnetic-logo-text">BOOKLOG</div>
            </div>
        `;

        // 【ここが魔法のコア】マウスの動きに追従するマグネティック・ホバー計算
        container.addEventListener('mousemove', (e) => {
            // transitionを一時的に無効化し、遅延のないヌルッとした追従を実現
            container.style.transition = 'none';
            
            const rect = container.getBoundingClientRect();
            // 要素の中心からのマウスの距離を -1.0 〜 1.0 の範囲で算出
            const x = ((e.clientX - rect.left) / rect.width - 0.5) * 2;
            const y = ((e.clientY - rect.top) / rect.height - 0.5) * 2;
            
            // X/Y軸の移動（最大5px）と、3D回転（最大10度）を適用
            // 値が絶妙にチューニングされており、上品に吸い付きます
            container.style.transform = `translate(${x * 5}px, ${y * 5}px) rotateX(${-y * 10}deg) rotateY(${x * 10}deg)`;
        });

        // マウスが離れたら、transitionを復活させてスッと元の位置へ戻す
        container.addEventListener('mouseleave', () => {
            container.style.transition = 'transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1)';
            container.style.transform = `translate(0px, 0px) rotateX(0deg) rotateY(0deg)`;
        });
    }
})();

// === 10000% Spotlight Search Logic & UI Injection ===
(function initSpotlightSearch() {
    // 1. 検索バーの中に美しい「虫眼鏡アイコン」と「iOS風クリアボタン」を注入
    ['searchInput', 'localSearchInput'].forEach(id => {
        const input = document.getElementById(id);
        if(input) {
            const parent = input.parentElement;
            
            // 虫眼鏡アイコンの生成と配置
            const icon = document.createElement('div');
            icon.className = 'absolute left-3 top-0 bottom-0 flex items-center justify-center pointer-events-none text-gray-400 dark:text-gray-500 transition-colors z-10';
            icon.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>';
            parent.insertBefore(icon, input);
            
            // フォーカス時にアイコンの色もアクセントカラーに連動させる
            input.addEventListener('focus', () => icon.classList.add('text-accent'));
            input.addEventListener('blur', () => icon.classList.remove('text-accent'));
            
            // クリアボタン（×）をiOSのグレーの丸ボタン風に美化
            const clearBtnId = id === 'searchInput' ? 'clearWebSearch' : 'clearLocalSearch';
            const clearBtn = document.getElementById(clearBtnId);
            if(clearBtn) {
                // クラスを完全に書き換えて美しくする
                clearBtn.className = 'hidden absolute right-2.5 top-1.5 bottom-1.5 w-5 h-5 my-auto bg-gray-300 dark:bg-gray-600 hover:bg-gray-400 dark:hover:bg-gray-500 text-white rounded-full flex items-center justify-center transition-colors haptic-tap z-10';
                clearBtn.innerHTML = '<svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>';
            }
        }
    });

    // 2. Google Books API検索（doSearch）関数をUI拡張のためにモンキーパッチ
    // ※APIキーや通信ロジック、addBook関数への連携などは元のまま完全に維持します
    window.doSearch = async function(q) {
        const sBox = document.getElementById('searchResults');
        // 元のコードと全く同じAPIキー
        const API_KEY = 'AIzaSyBm1kzNUkIq1OcnJNVhr6QSfbg4tUqbX3I';

        sBox.classList.remove('hidden');
        
        // 【革新ポイント】「検索中...」テキストの代わりに、美しいスケルトンローダーを表示
        sBox.innerHTML = `
            <div class="p-2 space-y-3">
                ${[1,2,3].map(() => `
                <div class="flex items-center gap-4 search-skeleton-pulse px-2">
                    <div class="w-10 h-14 bg-gray-200 dark:bg-gray-700 rounded-md"></div>
                    <div class="flex-1 space-y-2.5">
                        <div class="h-3 bg-gray-200 dark:bg-gray-700 rounded-full w-3/4"></div>
                        <div class="h-2 bg-gray-200 dark:bg-gray-700 rounded-full w-1/2"></div>
                    </div>
                </div>`).join('')}
            </div>
        `;

        try {
            const r = await fetch(`https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(q)}&maxResults=40&orderBy=relevance&key=${API_KEY}`);
            if (r.status === 429) {
                sBox.innerHTML='<div class="p-6 text-xs font-bold text-red-500 text-center">アクセスが集中しています。<br>しばらく待ってから再検索してください。</div>';
                return;
            }
            const d = await r.json();
            sBox.innerHTML = '';
            
            if (d.items) {
                const validItems = d.items.filter(i => i.volumeInfo);
                validItems.forEach(i => {
                    const div = document.createElement('div');
                    // カード風のレイアウト、ホバー時の滑らかなハイライト
                    div.className = "flex items-center p-2.5 hover:bg-black/5 dark:hover:bg-white/10 cursor-pointer rounded-xl haptic-tap transition-colors duration-200 mb-0.5 group";
                    
                    let rawImg = i.volumeInfo.imageLinks?.thumbnail || '';
                    if(rawImg.startsWith('http:')) rawImg = rawImg.replace('http:', 'https:');
                    const img = window.escapeHTML ? window.escapeHTML(rawImg) : rawImg;
                    const title = window.escapeHTML ? window.escapeHTML(i.volumeInfo.title||'No Title') : (i.volumeInfo.title||'No Title');
                    const authors = window.escapeHTML ? window.escapeHTML(i.volumeInfo.authors?.join(', ')||'') : (i.volumeInfo.authors?.join(', ')||'');
                    
                    // 右側の「追加」ボタンをiOSのピルボタン風に美化
                    div.innerHTML = `
                        <img src="${img}" class="w-10 h-14 object-cover mr-4 bg-gray-100 dark:bg-gray-800 rounded-md shadow-sm" onerror="this.src='https://via.placeholder.com/40x56?text=No+Img'">
                        <div class="flex-1 min-w-0 pr-2">
                            <p class="text-xs font-extrabold truncate dark:text-white leading-tight mb-1">${title}</p>
                            <p class="text-[10px] text-gray-500 truncate">${authors}</p>
                        </div>
                        <div class="px-3 py-1.5 rounded-full bg-blue-50 dark:bg-blue-900/30 text-[10px] font-bold text-accent group-hover:bg-accent group-hover:text-white transition-colors">追加</div>
                    `;
                    
                    // クリック時の挙動は元通り維持
                    div.onclick = () => { window.addBook(i); window.triggerHaptic(); };
                    sBox.appendChild(div);
                });
            } else {
                sBox.innerHTML='<div class="p-8 text-center text-xs font-bold text-gray-400">本が見つかりませんでした</div>';
            }
        } catch(e) {
            console.error(e);
            sBox.innerHTML='<div class="p-8 text-center text-xs font-bold text-red-400">エラーが発生しました</div>';
        }
    };
})();

// === 10000% Pro Dark Mode Logic & UI Injection ===
(function initProDarkMode() {
    // 1. 既存のダークモード切り替えボタンを探し、美しいモーフィングアイコンに差し替える
    const buttons = document.querySelectorAll('button');
    let themeBtn = null;
    buttons.forEach(btn => {
        // onclick属性に toggleTheme() が含まれているボタンを特定
        if (btn.getAttribute('onclick') && btn.getAttribute('onclick').includes('toggleTheme')) {
            themeBtn = btn;
        }
    });

    if (themeBtn) {
        // イベント(e)を受け取れるようにonclickを書き換え
        themeBtn.setAttribute('onclick', 'toggleTheme(event); triggerHaptic();');
        // 太陽と月が重なったSVGアイコンセットを注入
        themeBtn.innerHTML = `
            <div class="relative w-5 h-5 flex items-center justify-center">
                <svg class="theme-toggle-icon moon absolute w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg>
                <svg class="theme-toggle-icon sun absolute w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
            </div>
        `;
    }

    // 2. 既存のトグル関数を、波紋アニメーション対応版に安全に上書き
    window.toggleTheme = function(event) {
        // テーマ変更のコアロジック（既存機能をそのまま継承）
        const executeToggle = () => {
            const d = document.documentElement.classList.toggle('dark');
            localStorage.setItem('theme', d ? 'dark' : 'light');
            if (typeof window.updateStats === 'function') window.updateStats();
        };

        // View Transitions APIが未サポート、またはイベントが渡されていない場合は即時切り替え
        if (!document.startViewTransition || !event || !event.clientX) {
            executeToggle();
            return;
        }

        // クリックされた座標を取得（波紋の起点）
        const x = event.clientX;
        const y = event.clientY;
        
        // 画面の四隅のうち、クリック位置から最も遠い距離（波紋の最終半径）をピタゴラスの定理で計算
        const endRadius = Math.hypot(
            Math.max(x, window.innerWidth - x),
            Math.max(y, window.innerHeight - y)
        );

        // CSSに座標と半径を伝える
        document.documentElement.style.setProperty('--theme-x', `${x}px`);
        document.documentElement.style.setProperty('--theme-y', `${y}px`);
        document.documentElement.style.setProperty('--theme-r', `${endRadius}px`);

        // モーダルアニメーションとの干渉を防ぐための専用フラグクラスを付与
        document.documentElement.classList.add('theme-transitioning');

        // 波紋アニメーションの開始
        const transition = document.startViewTransition(() => {
            executeToggle();
        });

        // アニメーション完了後にフラグクラスを削除して綺麗に掃除
        transition.finished.then(() => {
            document.documentElement.classList.remove('theme-transitioning');
        }).catch(() => {
            document.documentElement.classList.remove('theme-transitioning');
        });
    };
})();

// === 10000% Pro Local Search Logic & UI Injection ===
(function initProLocalSearch() {
    const input = document.getElementById('localSearchInput');
    if (!input) return;

    const parent = input.parentElement;

    // 1. ⌘K (Ctrl+K) バッジの注入
    const badge = document.createElement('div');
    badge.className = 'search-shortcut-badge';
    // Macなら ⌘K、Windowsなら Ctrl+K を自動判別
    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
    badge.innerText = isMac ? '⌘K' : 'Ctrl+K';
    parent.appendChild(badge);

    // 2. 検索ヒット数を知らせる美しいピルの注入
    const resultsPill = document.createElement('div');
    resultsPill.className = 'search-results-pill';
    parent.appendChild(resultsPill);

    // 3. 超高速アクセスのためのグローバル・キーボードショートカット
    document.addEventListener('keydown', (e) => {
        // ⌘K または Ctrl+K で検索窓にフォーカス
        if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
            e.preventDefault();
            input.focus();
            input.select();
        }
        // 「/ (スラッシュ)」でも検索窓にフォーカス（GithubやTwitterと同じ挙動）
        if (e.key === '/' && document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA' && !document.activeElement.isContentEditable) {
            e.preventDefault();
            input.focus();
        }
        // Escキーで検索クリアしてフォーカスを外す
        if (e.key === 'Escape' && document.activeElement === input) {
            if (input.value !== '') {
                if(typeof clearLocalSearch === 'function') clearLocalSearch();
            }
            input.blur();
        }
    });

    // 4. 文字入力時のアニメーションとヒット数計算
    let hidePillTimeout;
    input.addEventListener('input', (e) => {
        const query = e.target.value;
        
        // 文字が入ったら ⌘K バッジを隠して、×（クリアボタン）の邪魔をさせない
        if (query.length > 0) {
            badge.classList.add('hidden-badge');
        } else {
            badge.classList.remove('hidden-badge');
        }

        // 検索処理自体は既存のイベントがやってくれるので、
        // ほんの少し待ってから「何冊表示されているか」を数えてピルに表示する
        setTimeout(() => {
            let count = 0;
            // 現在のビューに応じて表示されているカードをカウント
            if (window.currentView === 'grid' || window.currentView === 'tag') {
                count = document.querySelectorAll('.book-card-container').length;
            } else if (window.currentView === 'timeline') {
                count = document.querySelectorAll('.timeline-card').length;
            }

            if (query.length > 0) {
                // 件数を表示してピルを浮上させる
                resultsPill.innerHTML = `<span class="font-mono text-[0.85rem]">${count}</span> 冊ヒット`;
                resultsPill.classList.add('show');
                
                // 2.5秒後に自動でフワッと消える（タイピングの邪魔にならないように）
                clearTimeout(hidePillTimeout);
                hidePillTimeout = setTimeout(() => {
                    resultsPill.classList.remove('show');
                }, 2500);
            } else {
                resultsPill.classList.remove('show');
            }
        }, 50); // DOMの更新（applyView）を待つ
    });

    // フォーカスが外れたらピルを隠す
    input.addEventListener('blur', () => {
        resultsPill.classList.remove('show');
    });
})();

// === 10000% Ultra-Premium Cinematic Boot & Spatial Cascade Logic ===
(function initPremiumBoot() {
    // 1. 初回のみ再生されるスマート設計
    const hasBooted = sessionStorage.getItem('booklogPremiumSplashPlayed');
    let isInitialBoot = false;

    if (!hasBooted) {
        isInitialBoot = true;
        sessionStorage.setItem('booklogPremiumSplashPlayed', 'true');

        // 極上のスプラッシュDOMを生成
        const splash = document.createElement('div');
        splash.id = 'cinematic-splash';
        
        splash.innerHTML = `
            <div class="splash-aura-container">
                <div class="splash-aura"></div>
            </div>
            <div class="splash-logo-core">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
                    <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
                </svg>
                <span>BOOKLOG</span>
            </div>
        `;
        document.body.appendChild(splash);

        // ヘッダーを一旦隠す
        const header = document.querySelector('header');
        if(header) header.style.opacity = '0';

        // 2.2秒後にスプラッシュを静かにフェードアウト
        setTimeout(() => {
            splash.classList.add('fade-out');
            if(header) {
                header.style.opacity = '1';
                header.classList.add('header-cinematic-drop');
            }
            setTimeout(() => splash.remove(), 800);
        }, 2200);
    }

    // 2. 既存のビュー更新関数を安全に拡張し、ディレイカスケードを注入
    const originalApplyView = window.applyView;
    window.applyView = function() {
        if(typeof originalApplyView === 'function') originalApplyView();
        
        requestAnimationFrame(() => {
            const cards = document.querySelectorAll('.book-card-container, .timeline-card');
            
            // 初回ブート時はロゴが消え始めるタイミング（2.0秒）に合わせてカードを配り始める
            const baseDelay = isInitialBoot ? 2.0 : 0;
            isInitialBoot = false; 

            cards.forEach((card, index) => {
                card.classList.remove('cinematic-card-enter');
                void card.offsetWidth; // リフロー強制
                
                card.classList.add('cinematic-card-enter');
                // 最大0.6秒（20番目）でディレイを打ち切る
                const stagger = Math.min(index, 20) * 0.03;
                card.style.animationDelay = `${baseDelay + stagger}s`;
            });
        });
    };
    
    // 起動時にすでに描画されているものがあれば再発火
    if(typeof window.applyView === 'function') window.applyView();
})();
    </script>
</body>
</html>
